{
  "version": 3,
  "sources": ["../src/content/actions/snapshot.ts", "../src/content/actions/utils.ts", "../src/content/actions/click.ts", "../src/content/actions/dblclick.ts", "../src/content/actions/fill.ts", "../src/content/actions/type.ts", "../src/content/actions/focus.ts", "../src/content/actions/hover.ts", "../src/content/actions/press.ts", "../src/content/actions/check.ts", "../src/content/actions/select.ts", "../src/content/actions/get.ts", "../src/content/actions/is.ts", "../src/content/actions/scroll.ts", "../src/content/actions/scrollintoview.ts", "../src/content/actions/wait.ts", "../src/content/actions/find.ts", "../src/content/actions/mouse.ts", "../src/content/actions/drag.ts", "../src/content/executor.ts", "../src/content/index.ts"],
  "sourcesContent": ["/**\n * Snapshot Action\n * Generates an AI-optimized DOM snapshot with ref assignments\n * Adapted from Playwright's _snapshotForAI approach\n */\n\nimport type { RefRegistry } from '../../shared/types';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface SnapshotResult {\n  snapshot: string;\n  refRegistry: RefRegistry;\n}\n\ninterface TraversalState {\n  refCounter: number;\n  lines: string[];\n  registry: RefRegistry;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** ARIA roles that should get reference IDs (interactive elements) */\nconst INTERACTIVE_ROLES = new Set([\n  'button',\n  'link',\n  'textbox',\n  'searchbox',\n  'checkbox',\n  'radio',\n  'switch',\n  'slider',\n  'spinbutton',\n  'tab',\n  'tablist',\n  'combobox',\n  'listbox',\n  'option',\n  'menuitem',\n  'menuitemcheckbox',\n  'menuitemradio',\n  'gridcell',\n  'columnheader',\n  'rowheader',\n  'treeitem',\n  'dialog',\n]);\n\n/** Structural roles that should be included to show page structure */\nconst STRUCTURAL_ROLES = new Set([\n  'main',\n  'navigation',\n  'complementary',\n  'region',\n  'banner',\n  'contentinfo',\n  'article',\n  'search',\n  'form',\n  'dialog',\n  'alertdialog',\n  'progressbar',\n]);\n\n/** Roles that should show their text content */\nconst TEXT_ROLES = new Set([\n  'heading',\n  'heading1',\n  'heading2',\n  'heading3',\n  'heading4',\n  'heading5',\n  'heading6',\n  'status',\n  'alert',\n  'paragraph',\n  'listitem',\n]);\n\n/** Tags to skip entirely (including their children) */\nconst SKIP_TAGS = new Set([\n  'script',\n  'style',\n  'noscript',\n  'meta',\n  'link',\n  'base',\n  'title',\n  'svg',\n  'path',\n  'defs',\n  'clippath',\n  'lineargradient',\n  'radialgradient',\n]);\n\n// =============================================================================\n// REF REGISTRY FACTORY\n// =============================================================================\n\nexport function createRefRegistry(): RefRegistry {\n  const entries = new Map<string, Element>();\n  return {\n    entries,\n    clear() {\n      entries.clear();\n    },\n    set(ref: string, element: Element) {\n      entries.set(ref, element);\n    },\n    get(ref: string) {\n      return entries.get(ref);\n    },\n  };\n}\n\n// =============================================================================\n// MAIN FUNCTION\n// =============================================================================\n\n/**\n * Generate a snapshot of the current page DOM\n * - Traverses visible elements\n * - Assigns refs to interactive elements\n * - Returns compact text representation for LLM consumption\n */\nexport async function generateSnapshot(timeout: number = 5000): Promise<SnapshotResult> {\n  const clampedTimeout = Math.max(500, Math.min(60_000, timeout));\n\n  return new Promise((resolve) => {\n    const timer = setTimeout(() => {\n      resolve({\n        snapshot: '(snapshot timed out)',\n        refRegistry: createRefRegistry(),\n      });\n    }, clampedTimeout);\n\n    try {\n      const result = buildSnapshot();\n      clearTimeout(timer);\n      resolve(result);\n    } catch (error) {\n      clearTimeout(timer);\n      resolve({\n        snapshot: `(snapshot error: ${String(error)})`,\n        refRegistry: createRefRegistry(),\n      });\n    }\n  });\n}\n\n// =============================================================================\n// CORE ALGORITHM\n// =============================================================================\n\nfunction buildSnapshot(): SnapshotResult {\n  const state: TraversalState = {\n    refCounter: 0,\n    lines: [],\n    registry: createRefRegistry(),\n  };\n\n  const rootElement = document.body || document.documentElement;\n  if (!rootElement) {\n    return {\n      snapshot: '(no document)',\n      refRegistry: state.registry,\n    };\n  }\n\n  const rootName = document.title?.trim() ? cleanText(document.title) : null;\n  state.refCounter++;\n  const rootRef = `e${state.refCounter}`;\n  state.registry.set(rootRef, document.documentElement || rootElement);\n  state.lines.push(buildElementLine('RootWebArea', rootName, rootRef, 0));\n\n  traverseDOM(rootElement, 1, state);\n\n  return {\n    snapshot: state.lines.length > 0 ? state.lines.join('\\n') : '(empty page)',\n    refRegistry: state.registry,\n  };\n}\n\n// =============================================================================\n// DOM TRAVERSAL\n// =============================================================================\n\nfunction traverseDOM(element: Element, depth: number, state: TraversalState, insideInteractive: boolean = false): void {\n  const tag = element.tagName.toLowerCase();\n\n  // Skip certain tags entirely\n  if (SKIP_TAGS.has(tag)) {\n    return;\n  }\n\n  // Check visibility\n  if (!isElementVisible(element)) {\n    return;\n  }\n\n  const role = getAccessibilityRole(element);\n  const isInteractive = role !== null && INTERACTIVE_ROLES.has(role);\n  const isStructural = role !== null && STRUCTURAL_ROLES.has(role);\n  const isTextRole = role !== null && TEXT_ROLES.has(role);\n  const isClickable = isElementClickable(element);\n  const name = getAccessibleName(element);\n\n  // Determine if this element should be included in output\n  // Skip generic elements inside interactive parents (they just add noise)\n  const isGeneric = !role || role === 'generic';\n  const skipBecauseNested = insideInteractive && isGeneric && !isInteractive;\n\n  const shouldInclude = !skipBecauseNested && (isInteractive || isStructural || isTextRole || isClickable || Boolean(name));\n\n  // Assign ref to interactive elements (but not to nested children of interactive elements)\n  let ref: string | undefined;\n  if ((isInteractive || isClickable) && !insideInteractive) {\n    state.refCounter++;\n    ref = `e${state.refCounter}`;\n    state.registry.set(ref, element);\n  }\n\n  // Output this element if it should be included\n  if (shouldInclude) {\n    const displayRole = role || 'generic';\n    const line = buildElementLine(displayRole, name, ref, depth);\n    state.lines.push(line);\n  }\n\n  // Recurse into children - mark as inside interactive if this element is interactive\n  const nextDepth = shouldInclude ? depth + 1 : depth;\n  const nextInsideInteractive = insideInteractive || isInteractive || (isClickable && !isGeneric);\n\n  for (const child of element.children) {\n    traverseDOM(child, nextDepth, state, nextInsideInteractive);\n  }\n}\n\n// =============================================================================\n// VISIBILITY CHECK\n// =============================================================================\n\nfunction isElementVisible(element: Element): boolean {\n  const tag = element.tagName.toLowerCase();\n\n  // head is never visible\n  if (tag === 'head') {\n    return false;\n  }\n\n  try {\n    const style = window.getComputedStyle(element);\n    if (style.display === 'none' || style.visibility === 'hidden') {\n      return false;\n    }\n\n    // Check opacity (but allow very low opacity as it might still be interactive)\n    if (style.opacity === '0') {\n      return false;\n    }\n\n    // Note: We removed the offsetParent check as it's too aggressive for modern SPAs\n    // Many Twitter/X elements have offsetParent === null but are still visible and interactive\n  } catch {\n    // getComputedStyle can throw in some edge cases\n    return true;\n  }\n\n  if (element.getAttribute('aria-hidden') === 'true') {\n    return false;\n  }\n\n  return true;\n}\n\n// =============================================================================\n// CLICKABILITY CHECK\n// =============================================================================\n\n/**\n * Check if element is clickable (has click handlers or is focusable)\n * This catches elements that don't have explicit ARIA roles but are still interactive\n */\nfunction isElementClickable(element: Element): boolean {\n  const tag = element.tagName.toLowerCase();\n  const htmlElement = element as HTMLElement;\n\n  // Iframes are almost always interactive\n  if (tag === 'iframe') {\n    return true;\n  }\n\n  // Check for tabindex (makes element focusable/clickable)\n  const tabindex = element.getAttribute('tabindex');\n  if (tabindex !== null && tabindex !== '-1') {\n    return true;\n  }\n\n  // Check for onclick attribute\n  if (element.hasAttribute('onclick')) {\n    return true;\n  }\n\n  // Check for data-testid that suggests interactivity (common in Twitter/X)\n  const testId = element.getAttribute('data-testid');\n  if (testId && (testId.includes('button') || testId.includes('Button') || testId.includes('click') || testId.includes('link'))) {\n    return true;\n  }\n\n  // Check for cursor: pointer which often indicates clickability\n  try {\n    const style = window.getComputedStyle(element);\n    if (style.cursor === 'pointer') {\n      // Only count as clickable if it also has some text or is meaningfully sized\n      const rect = element.getBoundingClientRect();\n      if (rect.width > 10 && rect.height > 10) {\n        return true;\n      }\n    }\n  } catch {\n    // Ignore style errors\n  }\n\n  // Check for contenteditable\n  if (htmlElement.isContentEditable) {\n    return true;\n  }\n\n  return false;\n}\n\n// =============================================================================\n// ACCESSIBILITY PROPERTIES\n// =============================================================================\n\nfunction getAccessibilityRole(element: Element): string | null {\n  // Check explicit ARIA role first\n  const explicitRole = element.getAttribute('role');\n  if (explicitRole) {\n    return explicitRole.toLowerCase();\n  }\n\n  // Get implicit role from tag\n  return getImplicitRole(element);\n}\n\nfunction getImplicitRole(element: Element): string | null {\n  const tag = element.tagName.toLowerCase();\n\n  switch (tag) {\n    case 'button':\n      return 'button';\n    case 'a':\n      return element.hasAttribute('href') ? 'link' : null;\n    case 'input':\n      return getInputRole(element as HTMLInputElement);\n    case 'textarea':\n      return 'textbox';\n    case 'select':\n      return 'combobox';\n    case 'option':\n      return 'option';\n    case 'h1':\n      return 'heading1';\n    case 'h2':\n      return 'heading2';\n    case 'h3':\n      return 'heading3';\n    case 'h4':\n      return 'heading4';\n    case 'h5':\n      return 'heading5';\n    case 'h6':\n      return 'heading6';\n    case 'p':\n      return 'paragraph';\n    case 'nav':\n      return 'navigation';\n    case 'main':\n      return 'main';\n    case 'header':\n      return 'banner';\n    case 'footer':\n      return 'contentinfo';\n    case 'article':\n      return 'article';\n    case 'aside':\n      return 'complementary';\n    case 'section':\n      return 'region';\n    case 'form':\n      return 'form';\n    case 'ul':\n    case 'ol':\n      return 'list';\n    case 'li':\n      return 'listitem';\n    case 'table':\n      return 'table';\n    case 'tr':\n      return 'row';\n    case 'td':\n      return 'gridcell';\n    case 'th':\n      return 'columnheader';\n    case 'img':\n      return element.hasAttribute('alt') ? 'img' : null;\n    case 'dialog':\n      return 'dialog';\n    default:\n      return null;\n  }\n}\n\nfunction getInputRole(input: HTMLInputElement): string {\n  const type = input.type || 'text';\n  switch (type) {\n    case 'checkbox':\n      return 'checkbox';\n    case 'radio':\n      return 'radio';\n    case 'range':\n      return 'slider';\n    case 'number':\n      return 'spinbutton';\n    case 'search':\n      return 'searchbox';\n    case 'submit':\n    case 'button':\n    case 'reset':\n      return 'button';\n    case 'hidden':\n      return \"\";\n    default:\n      return 'textbox';\n  }\n}\n\nfunction getAccessibleName(element: Element): string | null {\n  // 1. aria-label (highest priority)\n  const ariaLabel = element.getAttribute('aria-label');\n  if (ariaLabel?.trim()) {\n    return cleanText(ariaLabel);\n  }\n\n  // 2. aria-labelledby\n  const ariaLabelledby = element.getAttribute('aria-labelledby');\n  if (ariaLabelledby) {\n    const names = ariaLabelledby\n      .split(' ')\n      .map((id) => document.getElementById(id)?.textContent?.trim())\n      .filter(Boolean);\n    if (names.length > 0) {\n      return cleanText(names.join(' '));\n    }\n  }\n\n  const tag = element.tagName.toLowerCase();\n\n  // 3. title attribute\n  const title = element.getAttribute('title');\n  if (title?.trim()) {\n    return cleanText(title);\n  }\n\n  // 4. alt attribute (for images)\n  if (tag === 'img') {\n    const alt = element.getAttribute('alt');\n    if (alt?.trim()) {\n      return cleanText(alt);\n    }\n  }\n\n  // 5. placeholder (for inputs)\n  if (tag === 'input') {\n    const input = element as HTMLInputElement;\n    if (input.placeholder?.trim()) {\n      return cleanText(input.placeholder);\n    }\n  }\n\n  if (tag === 'textarea') {\n    const textarea = element as HTMLTextAreaElement;\n    if (textarea.placeholder?.trim()) {\n      return cleanText(textarea.placeholder);\n    }\n  }\n\n  // 6. Associated label (inputs)\n  if (tag === 'input') {\n    const input = element as HTMLInputElement;\n    // Check for associated label\n    const label = findLabelFor(input);\n    if (label) {\n      return cleanText(label);\n    }\n  }\n\n  // 7. Direct text content (immediate children only)\n  const text = getDirectTextContent(element);\n  if (text) {\n    return cleanText(text);\n  }\n\n  // 8. For interactive elements, fall back to innerText (includes nested text)\n  // This handles buttons like <div role=\"button\"><div><span>Click me</span></div></div>\n  const role = element.getAttribute('role');\n  const isInteractiveElement = role && INTERACTIVE_ROLES.has(role.toLowerCase());\n  const isClickableElement = element.hasAttribute('tabindex') ||\n    (element as HTMLElement).style?.cursor === 'pointer';\n\n  if (isInteractiveElement || isClickableElement || tag === 'button' || tag === 'a') {\n    const htmlElement = element as HTMLElement;\n    if ('innerText' in htmlElement) {\n      const innerTextValue = htmlElement.innerText?.trim();\n      if (innerTextValue && innerTextValue.length < 200 && !looksLikeCode(innerTextValue)) {\n        return cleanText(innerTextValue);\n      }\n    }\n  }\n\n  // 9. value (for form elements)\n  if (tag === 'input' || tag === 'textarea' || tag === 'select') {\n    const value = (element as HTMLInputElement).value;\n    if (value?.trim()) {\n      return cleanText(value);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get direct text content, only from immediate child text nodes\n * This avoids grabbing text from deeply nested interactive elements\n */\nfunction getDirectTextContent(element: Element): string | null {\n  // Only collect text from direct text node children, not all descendants\n  let directText = '';\n\n  for (const child of element.childNodes) {\n    if (child.nodeType === Node.TEXT_NODE) {\n      const text = child.textContent?.trim();\n      if (text) {\n        directText += (directText ? ' ' : '') + text;\n      }\n    }\n  }\n\n  if (directText && !looksLikeCode(directText)) {\n    return directText;\n  }\n\n  return null;\n}\n\n/**\n * Find label text for an input element\n */\nfunction findLabelFor(input: HTMLInputElement): string | null {\n  // Check for label wrapping the input\n  const parentLabel = input.closest('label');\n  if (parentLabel) {\n    const labelText = parentLabel.textContent?.trim();\n    if (labelText) {\n      return labelText;\n    }\n  }\n\n  // Check for label with for attribute\n  const id = input.id;\n  if (id) {\n    const label = document.querySelector(`label[for=\"${id}\"]`);\n    if (label) {\n      const labelText = label.textContent?.trim();\n      if (labelText) {\n        return labelText;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Check if text looks like code/CSS/script content\n */\nfunction looksLikeCode(text: string): boolean {\n  if (text.length > 200) {\n    return true;\n  }\n\n  if (/[<>]/.test(text)) {\n    return true;\n  }\n\n  const lowered = text.toLowerCase();\n  if (\n    lowered.includes('<style') ||\n    lowered.includes('<script') ||\n    lowered.includes('::-webkit') ||\n    lowered.includes('input::placeholder')\n  ) {\n    return true;\n  }\n\n  // Check for common code patterns\n  const codePatterns = [\n    /^\\s*[\\{\\[]/, // Starts with { or [\n    /[{};]\\s*$/, // Ends with { } or ;\n    /:\\s*[a-z-]+\\s*;/, // CSS property pattern\n    /\\{\\s*\\n/, // Multi-line block\n    /^\\s*\\/[\\/*]/, // Comment start\n    /^\\s*@(media|import|keyframes|font-face)/, // CSS at-rules\n    /^\\s*(function|const|let|var|import|export)\\s/, // JS keywords\n    /::\\w+/, // CSS pseudo-elements\n    /\\([^)]*:[^)]*\\)/, // Function with colon (like url())\n  ];\n\n  return codePatterns.some((pattern) => pattern.test(text));\n}\n\n/**\n * Clean and truncate text for output\n */\nfunction cleanText(text: string): string {\n  // Normalize whitespace\n  let cleaned = text.replace(/\\s+/g, ' ').trim();\n\n  return cleaned;\n}\n\n// =============================================================================\n// OUTPUT FORMATTING\n// =============================================================================\n\nfunction buildElementLine(\n  role: string,\n  name: string | null,\n  ref: string | undefined,\n  depth: number\n): string {\n  const indent = '  '.repeat(depth);\n  let line = `${indent}- ${role}`;\n\n  if (name) {\n    // Escape quotes in name\n    const escapedName = name.replace(/\"/g, '\\\\\"');\n    line += ` \"${escapedName}\"`;\n  }\n\n  if (ref) {\n    line += ` [ref=${ref}]`;\n  }\n\n  return line;\n}\n", "/**\n * Shared utilities for DOM actions\n */\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Delay after scrolling to allow animation to complete (ms) */\nexport const SCROLL_DELAY_MS = 300;\n\n/** Delay after focusing an element (ms) */\nexport const FOCUS_DELAY_MS = 100;\n\n/** Minimum visibility ratio to consider element \"in viewport\" (0-1) */\nconst MIN_VIEWPORT_RATIO = 0.5;\n\n// =============================================================================\n// VISIBILITY CHECKS\n// =============================================================================\n\n/**\n * Check if an element is visible on the page\n * Checks display, visibility, offsetParent, and aria-hidden\n */\nexport function isElementVisible(element: Element): boolean {\n  const style = window.getComputedStyle(element);\n  \n  if (style.display === 'none' || style.visibility === 'hidden') {\n    return false;\n  }\n\n  // Check if element has layout (offsetParent is null for hidden elements)\n  // Note: Need to handle both HTMLElement and SVGElement\n  if ('offsetParent' in element) {\n    const htmlElement = element as HTMLElement;\n    if (htmlElement.offsetParent === null) {\n      // Fixed/sticky elements have null offsetParent but are still visible\n      if (style.position !== 'fixed' && style.position !== 'sticky') {\n        // Exception for body/html which always have null offsetParent\n        const tag = element.tagName.toLowerCase();\n        if (tag !== 'body' && tag !== 'html') {\n          return false;\n        }\n      }\n    }\n  }\n\n  if (element.getAttribute('aria-hidden') === 'true') {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Check if an element is sufficiently visible in the viewport\n * Uses intersection ratio rather than requiring full visibility\n */\nexport function isInViewport(element: Element): boolean {\n  const rect = element.getBoundingClientRect();\n  const viewportHeight = window.innerHeight || document.documentElement.clientHeight;\n  const viewportWidth = window.innerWidth || document.documentElement.clientWidth;\n\n  // Calculate how much of the element is visible\n  const visibleTop = Math.max(0, rect.top);\n  const visibleLeft = Math.max(0, rect.left);\n  const visibleBottom = Math.min(viewportHeight, rect.bottom);\n  const visibleRight = Math.min(viewportWidth, rect.right);\n\n  const visibleWidth = Math.max(0, visibleRight - visibleLeft);\n  const visibleHeight = Math.max(0, visibleBottom - visibleTop);\n  const visibleArea = visibleWidth * visibleHeight;\n\n  const totalArea = rect.width * rect.height;\n  if (totalArea === 0) {\n    return false;\n  }\n\n  // Element is considered \"in viewport\" if at least MIN_VIEWPORT_RATIO is visible\n  return visibleArea / totalArea >= MIN_VIEWPORT_RATIO;\n}\n\n/**\n * Check if an element is disabled\n * Handles native disabled attribute and ARIA disabled state\n */\nexport function isElementDisabled(element: Element): boolean {\n  // Check native disabled property\n  if ('disabled' in element && (element as HTMLButtonElement).disabled) {\n    return true;\n  }\n\n  // Check aria-disabled\n  if (element.getAttribute('aria-disabled') === 'true') {\n    return true;\n  }\n\n  return false;\n}\n\n// =============================================================================\n// SCROLL HELPERS\n// =============================================================================\n\n/**\n * Scroll element into view if not sufficiently visible\n * Returns true if scrolling was performed\n */\nexport async function scrollIntoViewIfNeeded(element: Element): Promise<boolean> {\n  if (isInViewport(element)) {\n    return false;\n  }\n\n  element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });\n  await delay(SCROLL_DELAY_MS);\n  return true;\n}\n\n// =============================================================================\n// ELEMENT GEOMETRY\n// =============================================================================\n\n/**\n * Get the center coordinates of an element for mouse events\n */\nexport function getElementCenter(element: Element): { clientX: number; clientY: number; screenX: number; screenY: number } {\n  const rect = element.getBoundingClientRect();\n  const clientX = rect.left + rect.width / 2;\n  const clientY = rect.top + rect.height / 2;\n  \n  return {\n    clientX,\n    clientY,\n    screenX: window.screenX + clientX,\n    screenY: window.screenY + clientY,\n  };\n}\n\n// =============================================================================\n// TIMING HELPERS\n// =============================================================================\n\n/**\n * Promise-based delay\n */\nexport function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "/**\n * Click Action\n * Clicks an element by its ref identifier\n */\n\nimport type { RefRegistry } from '../../shared/types';\nimport {\n  isElementVisible,\n  isElementDisabled,\n  scrollIntoViewIfNeeded,\n  getElementCenter,\n} from './utils';\n\n/**\n * Click an element identified by ref\n * @param ref - The reference ID from a previous snapshot\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found, not in DOM, disabled, or cannot be clicked\n */\nexport async function clickElement(ref: string, registry: RefRegistry): Promise<void> {\n  // Look up element in registry\n  const element = registry.get(ref);\n  if (!element) {\n    throw new Error(`Element with ref \"${ref}\" not found in registry`);\n  }\n\n  // Verify element is still in DOM\n  if (!document.contains(element)) {\n    throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n  }\n\n  // Verify element is still visible\n  if (!isElementVisible(element)) {\n    throw new Error(`Element with ref \"${ref}\" is not visible`);\n  }\n\n  // Verify element is not disabled\n  if (isElementDisabled(element)) {\n    throw new Error(`Element with ref \"${ref}\" is disabled`);\n  }\n\n  // Scroll element into view if needed\n  await scrollIntoViewIfNeeded(element);\n\n  // Get element center coordinates for realistic mouse events\n  const coords = getElementCenter(element);\n\n  // Dispatch full event sequence: pointerdown -> mousedown -> pointerup -> mouseup -> click\n  // This is more realistic and compatible with modern frameworks (React, etc.)\n  const commonEventInit: MouseEventInit = {\n    bubbles: true,\n    cancelable: true,\n    view: window,\n    button: 0,\n    buttons: 1,\n    clientX: coords.clientX,\n    clientY: coords.clientY,\n    screenX: coords.screenX,\n    screenY: coords.screenY,\n  };\n\n  // Pointer events (modern standard)\n  element.dispatchEvent(new PointerEvent('pointerdown', { ...commonEventInit, isPrimary: true }));\n  element.dispatchEvent(new MouseEvent('mousedown', commonEventInit));\n\n  // Release\n  element.dispatchEvent(new PointerEvent('pointerup', { ...commonEventInit, buttons: 0, isPrimary: true }));\n  element.dispatchEvent(new MouseEvent('mouseup', { ...commonEventInit, buttons: 0 }));\n\n  // Final click\n  const clickEvent = new MouseEvent('click', { ...commonEventInit, buttons: 0 });\n  element.dispatchEvent(clickEvent);\n}\n", "/**\n * Double Click Action\n * Double-clicks an element by its ref identifier\n */\n\nimport type { RefRegistry } from '../../shared/types';\nimport {\n    isElementVisible,\n    isElementDisabled,\n    scrollIntoViewIfNeeded,\n    getElementCenter,\n} from './utils';\n\n/**\n * Double-click an element identified by ref\n * @param ref - The reference ID from a previous snapshot\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found, not in DOM, disabled, or cannot be clicked\n */\nexport async function dblclickElement(ref: string, registry: RefRegistry): Promise<void> {\n    // Look up element in registry\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    // Verify element is still in DOM\n    if (!document.contains(element)) {\n        throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n    }\n\n    // Verify element is still visible\n    if (!isElementVisible(element)) {\n        throw new Error(`Element with ref \"${ref}\" is not visible`);\n    }\n\n    // Verify element is not disabled\n    if (isElementDisabled(element)) {\n        throw new Error(`Element with ref \"${ref}\" is disabled`);\n    }\n\n    // Scroll element into view if needed\n    await scrollIntoViewIfNeeded(element);\n\n    // Get element center coordinates for realistic mouse events\n    const coords = getElementCenter(element);\n\n    const commonEventInit: MouseEventInit = {\n        bubbles: true,\n        cancelable: true,\n        button: 0,\n        buttons: 1,\n        clientX: coords.clientX,\n        clientY: coords.clientY,\n        screenX: coords.screenX,\n        screenY: coords.screenY,\n    };\n\n    // First click\n    element.dispatchEvent(new PointerEvent('pointerdown', { ...commonEventInit, isPrimary: true }));\n    element.dispatchEvent(new MouseEvent('mousedown', commonEventInit));\n    element.dispatchEvent(new PointerEvent('pointerup', { ...commonEventInit, buttons: 0, isPrimary: true }));\n    element.dispatchEvent(new MouseEvent('mouseup', { ...commonEventInit, buttons: 0 }));\n    element.dispatchEvent(new MouseEvent('click', { ...commonEventInit, buttons: 0, detail: 1 }));\n\n    // Second click\n    element.dispatchEvent(new PointerEvent('pointerdown', { ...commonEventInit, isPrimary: true }));\n    element.dispatchEvent(new MouseEvent('mousedown', commonEventInit));\n    element.dispatchEvent(new PointerEvent('pointerup', { ...commonEventInit, buttons: 0, isPrimary: true }));\n    element.dispatchEvent(new MouseEvent('mouseup', { ...commonEventInit, buttons: 0 }));\n    element.dispatchEvent(new MouseEvent('click', { ...commonEventInit, buttons: 0, detail: 2 }));\n\n    // Double click event\n    const dblClickEvent = new MouseEvent('dblclick', { ...commonEventInit, buttons: 0, detail: 2 });\n    element.dispatchEvent(dblClickEvent);\n}\n", "/**\n * Fill Action\n * Fills an input element by its ref identifier\n */\n\nimport type { RefRegistry } from '../../shared/types';\nimport {\n  isElementVisible,\n  scrollIntoViewIfNeeded,\n  delay,\n  FOCUS_DELAY_MS,\n} from './utils';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Input types that cannot be filled with text */\nconst NON_FILLABLE_INPUT_TYPES = new Set([\n  'button',\n  'submit',\n  'reset',\n  'checkbox',\n  'radio',\n  'file',\n  'image',\n  'range',\n  'color',\n]);\n\n// =============================================================================\n// MAIN FUNCTION\n// =============================================================================\n\n/**\n * Fill an input element identified by ref\n * @param ref - The reference ID from a previous snapshot\n * @param value - The value to fill\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found, not fillable, or cannot be filled\n */\nexport async function fillElement(ref: string, value: string, registry: RefRegistry): Promise<void> {\n  // Look up element in registry\n  const element = registry.get(ref);\n  if (!element) {\n    throw new Error(`Element with ref \"${ref}\" not found in registry`);\n  }\n\n  // Verify element is still in DOM\n  if (!document.contains(element)) {\n    throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n  }\n\n  // Verify element is still visible\n  if (!isElementVisible(element)) {\n    throw new Error(`Element with ref \"${ref}\" is not visible`);\n  }\n\n  // Verify element is fillable\n  const fillableCheck = isFillableElement(element);\n  if (!fillableCheck.fillable) {\n    throw new Error(`Element with ref \"${ref}\" is not fillable: ${fillableCheck.reason}`);\n  }\n\n  // Scroll into view if needed\n  await scrollIntoViewIfNeeded(element);\n\n  // Focus element and wait for focus to settle\n  const htmlElement = element as HTMLElement;\n  htmlElement.focus();\n  await delay(FOCUS_DELAY_MS);\n\n  // Dispatch keydown for frameworks that listen to it\n  element.dispatchEvent(new KeyboardEvent('keydown', { bubbles: true, cancelable: true }));\n\n  // Set value based on element type\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    element.value = value;\n  } else if (htmlElement.isContentEditable) {\n    // contenteditable element - use innerText to preserve line breaks\n    htmlElement.innerText = value;\n  }\n\n  // Dispatch InputEvent for better framework compatibility\n  const inputEvent = new InputEvent('input', {\n    bubbles: true,\n    cancelable: true,\n    inputType: 'insertText',\n    data: value,\n  });\n  element.dispatchEvent(inputEvent);\n\n  // Dispatch keyup\n  element.dispatchEvent(new KeyboardEvent('keyup', { bubbles: true, cancelable: true }));\n\n  // Dispatch change event\n  const changeEvent = new Event('change', {\n    bubbles: true,\n    cancelable: true,\n  });\n  element.dispatchEvent(changeEvent);\n}\n\n// =============================================================================\n// HELPERS\n// =============================================================================\n\ninterface FillableCheck {\n  fillable: boolean;\n  reason?: string;\n}\n\n/**\n * Check if an element is fillable (input, textarea, or contenteditable)\n * Returns detailed reason if not fillable\n */\nfunction isFillableElement(element: Element): FillableCheck {\n  if (element instanceof HTMLInputElement) {\n    const type = element.type?.toLowerCase() || 'text';\n\n    if (NON_FILLABLE_INPUT_TYPES.has(type)) {\n      return { fillable: false, reason: `input type \"${type}\" is not fillable` };\n    }\n    if (element.readOnly) {\n      return { fillable: false, reason: 'input is read-only' };\n    }\n    if (element.disabled) {\n      return { fillable: false, reason: 'input is disabled' };\n    }\n    return { fillable: true };\n  }\n\n  if (element instanceof HTMLTextAreaElement) {\n    if (element.readOnly) {\n      return { fillable: false, reason: 'textarea is read-only' };\n    }\n    if (element.disabled) {\n      return { fillable: false, reason: 'textarea is disabled' };\n    }\n    return { fillable: true };\n  }\n\n  // Check for contenteditable\n  if ((element as HTMLElement).isContentEditable) {\n    return { fillable: true };\n  }\n\n  return { fillable: false, reason: 'element is not an input, textarea, or contenteditable' };\n}\n", "/**\n * Type Action\n * Types text into an element by its ref identifier\n */\n\nimport type { RefRegistry, TypeParams } from '../../shared/types';\nimport {\n    isElementVisible,\n    scrollIntoViewIfNeeded,\n    delay,\n    FOCUS_DELAY_MS,\n} from './utils';\n\n/**\n * Type text into an element identified by ref\n * @param params - Type parameters\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found or not visible\n */\nexport async function typeElement(\n    params: TypeParams,\n    registry: RefRegistry\n): Promise<void> {\n    const { ref, text, delay: charDelay = 0 } = params;\n    // Look up element in registry\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    // Verify element is still in DOM\n    if (!document.contains(element)) {\n        throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n    }\n\n    // Verify element is still visible\n    if (!isElementVisible(element)) {\n        throw new Error(`Element with ref \"${ref}\" is not visible`);\n    }\n\n    // Scroll into view if needed\n    await scrollIntoViewIfNeeded(element);\n\n    // Focus element and wait for focus to settle\n    const htmlElement = element as HTMLElement;\n    htmlElement.focus();\n    await delay(FOCUS_DELAY_MS);\n\n    // Type character by character\n    for (const char of text) {\n        // Dispatch keydown\n        element.dispatchEvent(new KeyboardEvent('keydown', {\n            key: char,\n            bubbles: true,\n            cancelable: true,\n        }));\n\n        // Insert character\n        // We use execCommand if possible as it handles selection/cursor automatically\n        // and triggers all necessary framework events (React, etc.)\n        const inserted = typeof document.execCommand === 'function' && document.execCommand('insertText', false, char);\n\n        if (!inserted) {\n            // Fallback for elements where execCommand might fail\n            if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n                const start = element.selectionStart || 0;\n                const end = element.selectionEnd || 0;\n                const val = element.value;\n                element.value = val.slice(0, start) + char + val.slice(end);\n                element.selectionStart = element.selectionEnd = start + 1;\n\n                // Manual input event if execCommand failed\n                element.dispatchEvent(new InputEvent('input', {\n                    bubbles: true,\n                    cancelable: true,\n                    inputType: 'insertText',\n                    data: char,\n                }));\n            } else if (htmlElement.isContentEditable) {\n                htmlElement.innerText += char;\n                // Move cursor to end\n                const range = document.createRange();\n                const sel = window.getSelection();\n                range.selectNodeContents(htmlElement);\n                range.collapse(false);\n                sel?.removeAllRanges();\n                sel?.addRange(range);\n            }\n        }\n\n        // Dispatch keyup\n        element.dispatchEvent(new KeyboardEvent('keyup', {\n            key: char,\n            bubbles: true,\n            cancelable: true,\n        }));\n\n        if (charDelay > 0) {\n            await delay(charDelay);\n        }\n    }\n\n    // Dispatch change event at the end\n    element.dispatchEvent(new Event('change', {\n        bubbles: true,\n        cancelable: true,\n    }));\n}\n", "/**\n * Focus Action\n * Focuses an element by its ref identifier\n */\n\nimport type { RefRegistry } from '../../shared/types';\nimport {\n    isElementVisible,\n    scrollIntoViewIfNeeded,\n    delay,\n    FOCUS_DELAY_MS,\n} from './utils';\n\n/**\n * Focus an element identified by ref\n * @param ref - The reference ID from a previous snapshot\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found or not visible\n */\nexport async function focusElement(ref: string, registry: RefRegistry): Promise<void> {\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    if (!document.contains(element)) {\n        throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n    }\n\n    if (!isElementVisible(element)) {\n        throw new Error(`Element with ref \"${ref}\" is not visible`);\n    }\n\n    await scrollIntoViewIfNeeded(element);\n\n    const htmlElement = element as HTMLElement;\n    htmlElement.focus();\n    await delay(FOCUS_DELAY_MS);\n}\n", "/**\n * Hover Action\n * Hovers an element by its ref identifier\n */\n\nimport type { RefRegistry } from '../../shared/types';\nimport {\n    isElementVisible,\n    scrollIntoViewIfNeeded,\n} from './utils';\n\n/**\n * Hover an element identified by ref\n * @param ref - The reference ID from a previous snapshot\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found or not visible\n */\nexport async function hoverElement(ref: string, registry: RefRegistry): Promise<void> {\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    if (!document.contains(element)) {\n        throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n    }\n\n    if (!isElementVisible(element)) {\n        throw new Error(`Element with ref \"${ref}\" is not visible`);\n    }\n\n    await scrollIntoViewIfNeeded(element);\n\n    const rect = element.getBoundingClientRect();\n    const clientX = rect.left + rect.width / 2;\n    const clientY = rect.top + rect.height / 2;\n\n    const commonEventInit = {\n        bubbles: true,\n        cancelable: true,\n        clientX,\n        clientY,\n        screenX: clientX,\n        screenY: clientY,\n    };\n\n    // Dispatch pointer events\n    element.dispatchEvent(new PointerEvent('pointerover', { ...commonEventInit, isPrimary: true }));\n    element.dispatchEvent(new PointerEvent('pointerenter', { ...commonEventInit, isPrimary: true }));\n    element.dispatchEvent(new PointerEvent('pointermove', { ...commonEventInit, isPrimary: true }));\n\n    // Dispatch mouse events\n    element.dispatchEvent(new MouseEvent('mouseover', commonEventInit));\n    element.dispatchEvent(new MouseEvent('mouseenter', commonEventInit));\n    element.dispatchEvent(new MouseEvent('mousemove', commonEventInit));\n}\n", "/**\n * Press Action\n * Presses a key, optionally on a specific element\n */\n\nimport type { RefRegistry } from '../../shared/types';\nimport {\n    isElementVisible,\n    scrollIntoViewIfNeeded,\n    delay,\n    FOCUS_DELAY_MS,\n} from './utils';\n\n/**\n * Press a key\n * @param params - Object containing key and optional ref\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found or not visible\n */\nexport async function pressKey(\n    params: { key: string; ref?: string },\n    registry: RefRegistry\n): Promise<void> {\n    const { key, ref } = params;\n    let target: EventTarget = document.activeElement || document.body;\n\n    if (ref) {\n        const element = registry.get(ref);\n        if (!element) {\n            throw new Error(`Element with ref \"${ref}\" not found in registry`);\n        }\n\n        if (!document.contains(element)) {\n            throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n        }\n\n        if (!isElementVisible(element)) {\n            throw new Error(`Element with ref \"${ref}\" is not visible`);\n        }\n\n        await scrollIntoViewIfNeeded(element);\n        (element as HTMLElement).focus();\n        await delay(FOCUS_DELAY_MS);\n        target = element;\n    }\n\n    const eventInit = {\n        key,\n        bubbles: true,\n        cancelable: true,\n    };\n\n    target.dispatchEvent(new KeyboardEvent('keydown', eventInit));\n    target.dispatchEvent(new KeyboardEvent('keypress', eventInit));\n    target.dispatchEvent(new KeyboardEvent('keyup', eventInit));\n}\n", "/**\n * Check/Uncheck Action\n * Sets the checked state of a checkbox or radio button\n */\n\nimport type { RefRegistry } from '../../shared/types';\nimport {\n    isElementVisible,\n    scrollIntoViewIfNeeded,\n} from './utils';\n\n/**\n * Set the checked state of an element\n * @param ref - The reference ID from a previous snapshot\n * @param checked - The desired checked state\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found, not visible, or not a checkbox/radio\n */\nexport async function setChecked(\n    ref: string,\n    checked: boolean,\n    registry: RefRegistry\n): Promise<void> {\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    if (!document.contains(element)) {\n        throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n    }\n\n    if (!isElementVisible(element)) {\n        throw new Error(`Element with ref \"${ref}\" is not visible`);\n    }\n\n    if (!(element instanceof HTMLInputElement)) {\n        throw new Error(`Element with ref \"${ref}\" is not an input element`);\n    }\n\n    const type = element.type?.toLowerCase();\n    if (type !== 'checkbox' && type !== 'radio') {\n        throw new Error(`Element with ref \"${ref}\" is not a checkbox or radio button (type: ${type})`);\n    }\n\n    if (element.checked === checked) {\n        return; // Already in desired state\n    }\n\n    await scrollIntoViewIfNeeded(element);\n\n    // We simulate a click to trigger all side effects (React state changes, etc.)\n    // but we also ensure the state is set correctly if click doesn't do it.\n    element.click();\n\n    // If click didn't change it (e.g. event.preventDefault()), we might need to force it\n    // but usually click is what we want to simulate.\n    if (element.checked !== checked) {\n        element.checked = checked;\n        element.dispatchEvent(new Event('change', { bubbles: true }));\n        element.dispatchEvent(new Event('input', { bubbles: true }));\n    }\n}\n", "/**\n * Select Action\n * Selects an option in a dropdown by its ref identifier\n */\n\nimport type { RefRegistry, SelectParams } from '../../shared/types';\nimport {\n    isElementVisible,\n    scrollIntoViewIfNeeded,\n} from './utils';\n\n/**\n * Select an option in a dropdown\n * @param params - Select parameters\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found, not visible, or not a select element\n */\nexport async function selectOption(\n    params: SelectParams,\n    registry: RefRegistry\n): Promise<void> {\n    const { ref, value } = params;\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    if (!document.contains(element)) {\n        throw new Error(`Element with ref \"${ref}\" is no longer in the DOM`);\n    }\n\n    if (!isElementVisible(element)) {\n        throw new Error(`Element with ref \"${ref}\" is not visible`);\n    }\n\n    if (!(element instanceof HTMLSelectElement)) {\n        throw new Error(`Element with ref \"${ref}\" is not a select element`);\n    }\n\n    await scrollIntoViewIfNeeded(element);\n\n    // Try to find option by value first, then by text\n    let optionToSelect: HTMLOptionElement | null = null;\n\n    for (let i = 0; i < element.options.length; i++) {\n        const opt = element.options[i];\n        if (opt.value === value || opt.text.trim() === value) {\n            optionToSelect = opt;\n            break;\n        }\n    }\n\n    if (!optionToSelect) {\n        throw new Error(`Option with value or text \"${value}\" not found in select element`);\n    }\n\n    if (element.value === optionToSelect.value) {\n        return; // Already selected\n    }\n\n    element.value = optionToSelect.value;\n\n    // Dispatch events\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n}\n", "/**\n * Get Info Action\n * Retrieves information about elements or the page\n */\n\nimport type { RefRegistry, GetParams } from '../../shared/types';\nimport { isElementVisible } from './utils';\n\n/**\n * Get information based on params\n * @param params - Get parameters\n * @param registry - The ref registry from the last snapshot\n * @returns The requested information\n * @throws Error if element not found or invalid parameters\n */\nexport async function getInfo(params: GetParams, registry: RefRegistry): Promise<any> {\n    const { what, ref, selector, attrName } = params;\n\n    // Page-level info\n    if (what === 'title') {\n        return document.title;\n    }\n    if (what === 'url') {\n        return window.location.href;\n    }\n\n    // Selector-based info\n    if (what === 'count') {\n        if (!selector) {\n            throw new Error('Missing selector for count action');\n        }\n        return document.querySelectorAll(selector).length;\n    }\n\n    // Element-based info (requires ref)\n    if (!ref) {\n        throw new Error(`Missing ref for \"get ${what}\" action`);\n    }\n\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    switch (what) {\n        case 'text':\n            return (element as HTMLElement).innerText || element.textContent || '';\n\n        case 'html':\n            return element.outerHTML;\n\n        case 'value':\n            if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement || element instanceof HTMLSelectElement) {\n                return element.value;\n            }\n            throw new Error(`Element with ref \"${ref}\" does not have a value`);\n\n        case 'attr':\n            if (!attrName) {\n                throw new Error('Missing attrName for attr action');\n            }\n            return element.getAttribute(attrName);\n\n        case 'box': {\n            const rect = element.getBoundingClientRect();\n            return {\n                x: rect.left + window.scrollX,\n                y: rect.top + window.scrollY,\n                width: rect.width,\n                height: rect.height,\n                top: rect.top,\n                right: rect.right,\n                bottom: rect.bottom,\n                left: rect.left,\n            };\n        }\n\n        default:\n            throw new Error(`Unknown get info type: ${what}`);\n    }\n}\n", "/**\n * Check State Action\n * Checks the state of an element\n */\n\nimport type { RefRegistry, IsParams } from '../../shared/types';\nimport { isElementVisible, isElementDisabled } from './utils';\n\n/**\n * Check state based on params\n * @param params - Is parameters\n * @param registry - The ref registry from the last snapshot\n * @returns Boolean indicating the state\n * @throws Error if element not found or invalid parameters\n */\nexport async function checkState(params: IsParams, registry: RefRegistry): Promise<boolean> {\n    const { what, ref } = params;\n\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    switch (what) {\n        case 'visible':\n            return isElementVisible(element);\n\n        case 'enabled':\n            return !isElementDisabled(element);\n\n        case 'checked':\n            if (element instanceof HTMLInputElement && (element.type === 'checkbox' || element.type === 'radio')) {\n                return element.checked;\n            }\n            throw new Error(`Element with ref \"${ref}\" is not a checkbox or radio button`);\n\n        default:\n            throw new Error(`Unknown check state type: ${what}`);\n    }\n}\n", "/**\n * Scroll Action\n * Scrolls the page or an element\n */\n\nimport type { RefRegistry, ScrollParams } from '../../shared/types';\n\nconst VALID_DIRECTIONS = ['up', 'down', 'left', 'right'] as const;\n\n/**\n * Scroll based on params\n * @param params - Scroll parameters\n * @param _registry - The ref registry from the last snapshot (reserved for future element scrolling)\n */\nexport async function scroll(params: ScrollParams, _registry: RefRegistry | null): Promise<void> {\n    const { direction, pixels = 300 } = params;\n\n    if (!direction || !VALID_DIRECTIONS.includes(direction as any)) {\n        throw new Error(`Invalid scroll direction: \"${direction}\". Must be one of: ${VALID_DIRECTIONS.join(', ')}`);\n    }\n\n    let x = 0;\n    let y = 0;\n\n    switch (direction) {\n        case 'up': y = -pixels; break;\n        case 'down': y = pixels; break;\n        case 'left': x = -pixels; break;\n        case 'right': x = pixels; break;\n    }\n\n    window.scrollBy({\n        left: x,\n        top: y,\n        behavior: 'smooth'\n    });\n}\n", "/**\n * Scroll Into View Action\n * Scrolls an element into the visible area of the browser window\n */\n\nimport type { RefRegistry } from '../../shared/types';\nimport { scrollIntoViewIfNeeded } from './utils';\n\n/**\n * Scroll element into view\n * @param ref - The reference ID from a previous snapshot\n * @param registry - The ref registry from the last snapshot\n * @throws Error if element not found\n */\nexport async function scrollIntoView(ref: string, registry: RefRegistry): Promise<void> {\n    const element = registry.get(ref);\n    if (!element) {\n        throw new Error(`Element with ref \"${ref}\" not found in registry`);\n    }\n\n    await scrollIntoViewIfNeeded(element);\n}\n", "/**\n * Wait Action\n * Waits for a specified time or for an element to appear/become visible\n */\n\nimport type { RefRegistry, WaitParams } from '../../shared/types';\nimport { isElementVisible } from './utils';\n\n/**\n * Wait based on params\n * @param params - Wait parameters\n * @param registry - The ref registry from the last snapshot\n */\nexport async function wait(params: WaitParams, registry: RefRegistry): Promise<void> {\n    const { ms, ref, selector } = params;\n\n    if (!ms && !ref && !selector) {\n        throw new Error('wait requires at least one parameter: ms, ref, or selector');\n    }\n\n    if (ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    if (ref) {\n        // Wait for element in registry to be visible\n        // Note: Registry is snapshot-local, so if it's not there now, it won't be there later\n        // unless we take a new snapshot. But we can check visibility of an existing ref.\n        const element = registry.get(ref);\n        if (!element) {\n            throw new Error(`Element with ref \"${ref}\" not found in registry`);\n        }\n\n        return new Promise((resolve, reject) => {\n            const start = Date.now();\n            const timeout = 10000; // 10s default\n            let stopped = false;\n\n            const check = () => {\n                if (stopped) return;\n                if (isElementVisible(element)) {\n                    stopped = true;\n                    resolve();\n                } else if (Date.now() - start > timeout) {\n                    stopped = true;\n                    reject(new Error(`Timeout waiting for element ${ref} to become visible`));\n                } else {\n                    setTimeout(check, 100);\n                }\n            };\n            check();\n        });\n    }\n\n    if (selector) {\n        return new Promise((resolve, reject) => {\n            const start = Date.now();\n            const timeout = 10000;\n            let stopped = false;\n\n            const check = () => {\n                if (stopped) return;\n                const element = document.querySelector(selector);\n                if (element && isElementVisible(element)) {\n                    stopped = true;\n                    resolve();\n                } else if (Date.now() - start > timeout) {\n                    stopped = true;\n                    reject(new Error(`Timeout waiting for selector \"${selector}\" to appear and be visible`));\n                } else {\n                    setTimeout(check, 100);\n                }\n            };\n            check();\n        });\n    }\n}\n", "/**\n * Find Action\n * Locates elements based on various criteria\n */\n\nimport type { RefRegistry, FindParams } from '../../shared/types';\nimport { isElementVisible } from './utils';\n\n// Counter for generating unique refs\nlet findRefCounter = 0;\n\n/**\n * Find element based on params\n * @param params - Find parameters\n * @param registry - The ref registry to populate\n * @returns The ref of the found element\n */\nexport async function findElement(params: FindParams, registry: RefRegistry): Promise<string | null> {\n    const { locator, value, text } = params;\n\n    let elements: Element[] = [];\n\n    switch (locator) {\n        case 'role':\n            // Very basic role search\n            elements = Array.from(document.querySelectorAll(`[role=\"${value}\"], ${value}`));\n            break;\n\n        case 'text':\n            elements = Array.from(document.querySelectorAll('*')).filter(el =>\n                el.textContent?.trim().includes(value) && el.children.length === 0\n            );\n            break;\n\n        case 'label':\n            elements = Array.from(document.querySelectorAll('label')).filter(l =>\n                l.textContent?.trim().includes(value)\n            ).map(l => {\n                if (l.htmlFor) return document.getElementById(l.htmlFor);\n                return l.querySelector('input, select, textarea');\n            }).filter((el): el is Element => el !== null);\n            break;\n\n        case 'placeholder':\n            elements = Array.from(document.querySelectorAll(`[placeholder*=\"${value}\"]`));\n            break;\n\n        case 'alt':\n            elements = Array.from(document.querySelectorAll(`[alt*=\"${value}\"]`));\n            break;\n\n        case 'title':\n            elements = Array.from(document.querySelectorAll(`[title*=\"${value}\"]`));\n            break;\n\n        case 'testid':\n            elements = Array.from(document.querySelectorAll(`[data-testid=\"${value}\"], [data-test-id=\"${value}\"], [data-test=\"${value}\"]`));\n            break;\n\n        case 'first':\n            elements = [document.querySelector(value)].filter((el): el is Element => el !== null);\n            break;\n\n        case 'last': {\n            const all = document.querySelectorAll(value);\n            elements = all.length > 0 ? [all[all.length - 1]] : [];\n            break;\n        }\n\n        case 'nth': {\n            const n = parseInt(text || '0');\n            const all = document.querySelectorAll(value);\n            elements = all.length > n ? [all[n]] : [];\n            break;\n        }\n    }\n\n    // Filter for visible and interactive if possible\n    const found = elements.find(el => isElementVisible(el));\n\n    if (found) {\n        // Check if it's already in registry\n        for (const [ref, el] of (registry as any).entries.entries()) {\n            if (el === found) return ref;\n        }\n\n        // Assign new ref if not found - use counter + timestamp for uniqueness\n        const newRef = `f${Date.now()}_${++findRefCounter}`;\n        registry.set(newRef, found);\n        return newRef;\n    }\n\n    return null;\n}\n", "/**\n * Mouse Action\n * Performs low-level mouse interactions\n */\n\nimport type { MouseParams } from '../../shared/types';\n\n/**\n * Get element at coordinates or throw error\n */\nfunction getElementAtPoint(x: number, y: number): Element {\n    const element = document.elementFromPoint(x, y);\n    if (!element) {\n        throw new Error(`No element found at coordinates (${x}, ${y})`);\n    }\n    return element;\n}\n\n/**\n * Perform mouse action\n * @param params - Mouse parameters\n */\nexport async function mouseAction(params: MouseParams): Promise<void> {\n    const { action, x = 0, y = 0, button = 0, dx = 0, dy = 0 } = params;\n\n    switch (action) {\n        case 'move': {\n            const target = getElementAtPoint(x, y);\n            const event = new MouseEvent('mousemove', {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n                clientX: x,\n                clientY: y\n            });\n            target.dispatchEvent(event);\n            break;\n        }\n\n        case 'down': {\n            const target = getElementAtPoint(x, y);\n            const event = new MouseEvent('mousedown', {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n                clientX: x,\n                clientY: y,\n                button: button\n            });\n            target.dispatchEvent(event);\n            break;\n        }\n\n        case 'up': {\n            const target = getElementAtPoint(x, y);\n            const event = new MouseEvent('mouseup', {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n                clientX: x,\n                clientY: y,\n                button: button\n            });\n            target.dispatchEvent(event);\n            break;\n        }\n\n        case 'wheel': {\n            const target = document.elementFromPoint(x, y);\n            const event = new WheelEvent('wheel', {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n                clientX: x,\n                clientY: y,\n                deltaX: dx,\n                deltaY: dy\n            });\n            if (target) {\n                target.dispatchEvent(event);\n            } else {\n                // No element at point, scroll the window directly\n                window.scrollBy(dx, dy);\n            }\n            break;\n        }\n\n        default: {\n            throw new Error(`Unknown mouse action: ${action}`);\n        }\n    }\n}\n", "/**\n * Drag Action\n * Simulates drag and drop between two elements\n */\n\nimport type { RefRegistry, DragParams } from '../../shared/types';\nimport { scrollIntoViewIfNeeded } from './utils';\n\n/**\n * Perform drag and drop\n * @param params - Drag parameters\n * @param registry - The ref registry\n * @throws Error if elements not found\n */\nexport async function dragAndDrop(params: DragParams, registry: RefRegistry): Promise<void> {\n    const { src, dst } = params;\n\n    const srcEl = registry.get(src);\n    const dstEl = registry.get(dst);\n\n    if (!srcEl) throw new Error(`Source element \"${src}\" not found in registry`);\n    if (!dstEl) throw new Error(`Destination element \"${dst}\" not found in registry`);\n\n    // Verify elements are still in the DOM\n    if (!document.contains(srcEl)) {\n        throw new Error(`Source element \"${src}\" is no longer in the DOM`);\n    }\n    if (!document.contains(dstEl)) {\n        throw new Error(`Destination element \"${dst}\" is no longer in the DOM`);\n    }\n\n    await scrollIntoViewIfNeeded(srcEl);\n    await scrollIntoViewIfNeeded(dstEl);\n\n    const srcRect = srcEl.getBoundingClientRect();\n    const dstRect = dstEl.getBoundingClientRect();\n\n    // Calculate center coordinates for the drag events\n    const startX = srcRect.left + srcRect.width / 2;\n    const startY = srcRect.top + srcRect.height / 2;\n    const endX = dstRect.left + dstRect.width / 2;\n    const endY = dstRect.top + dstRect.height / 2;\n\n    // Dispatch drag events with proper coordinates\n    const dataTransfer = new DataTransfer();\n\n    srcEl.dispatchEvent(new DragEvent('dragstart', {\n        bubbles: true,\n        cancelable: true,\n        dataTransfer,\n        clientX: startX,\n        clientY: startY\n    }));\n\n    srcEl.dispatchEvent(new DragEvent('drag', {\n        bubbles: true,\n        cancelable: true,\n        dataTransfer,\n        clientX: startX,\n        clientY: startY\n    }));\n\n    dstEl.dispatchEvent(new DragEvent('dragenter', {\n        bubbles: true,\n        cancelable: true,\n        dataTransfer,\n        clientX: endX,\n        clientY: endY\n    }));\n\n    dstEl.dispatchEvent(new DragEvent('dragover', {\n        bubbles: true,\n        cancelable: true,\n        dataTransfer,\n        clientX: endX,\n        clientY: endY\n    }));\n\n    dstEl.dispatchEvent(new DragEvent('drop', {\n        bubbles: true,\n        cancelable: true,\n        dataTransfer,\n        clientX: endX,\n        clientY: endY\n    }));\n\n    srcEl.dispatchEvent(new DragEvent('dragend', {\n        bubbles: true,\n        cancelable: true,\n        dataTransfer,\n        clientX: endX,\n        clientY: endY\n    }));\n}\n", "/**\n * Action Executor\n * Dispatches incoming requests to appropriate action handlers\n */\n\nimport type { ContentRequest, ContentResponse } from '../shared/messages';\nimport type { RefRegistry } from '../shared/types';\nimport { generateSnapshot, createRefRegistry } from './actions/snapshot';\nimport { clickElement } from './actions/click';\nimport { dblclickElement } from './actions/dblclick';\nimport { fillElement } from './actions/fill';\nimport { typeElement } from './actions/type';\nimport { focusElement } from './actions/focus';\nimport { hoverElement } from './actions/hover';\nimport { pressKey } from './actions/press';\nimport { setChecked } from './actions/check';\nimport { selectOption } from './actions/select';\nimport { getInfo } from './actions/get';\nimport { checkState } from './actions/is';\nimport { scroll } from './actions/scroll';\nimport { scrollIntoView } from './actions/scrollintoview';\nimport { wait } from './actions/wait';\nimport { findElement } from './actions/find';\nimport { mouseAction } from './actions/mouse';\nimport { dragAndDrop } from './actions/drag';\n\n// Module-level ref registry (snapshot-local, cleared on each snapshot)\nlet currentRegistry: RefRegistry | null = null;\n\n/**\n * Execute an action request from the background script\n */\nexport async function executeAction(request: ContentRequest): Promise<ContentResponse> {\n  try {\n    switch (request.action) {\n      case 'snapshot': {\n        const timeout = (request.params?.timeout as number | undefined) || 5000;\n        const result = await generateSnapshot(timeout);\n        currentRegistry = result.refRegistry;\n        // Expose registry for background script (e.g. for upload)\n        (window as any).__REF_REGISTRY__ = currentRegistry;\n        return {\n          success: true,\n          data: {\n            snapshot: result.snapshot,\n            url: window.location.href,\n            title: document.title,\n          },\n        };\n      }\n\n      case 'click': {\n        if (!currentRegistry) {\n          return {\n            success: false,\n            error: 'No active snapshot - call snapshot action first',\n          };\n        }\n        const ref = request.params?.ref as string | undefined;\n        if (!ref) {\n          return {\n            success: false,\n            error: 'Missing ref parameter for click action',\n          };\n        }\n        await clickElement(ref, currentRegistry);\n        return {\n          success: true,\n          data: { executed: true },\n        };\n      }\n\n      case 'dblclick': {\n        if (!currentRegistry) {\n          return {\n            success: false,\n            error: 'No active snapshot - call snapshot action first',\n          };\n        }\n        const ref = request.params?.ref as string | undefined;\n        if (!ref) {\n          return {\n            success: false,\n            error: 'Missing ref parameter for dblclick action',\n          };\n        }\n        await dblclickElement(ref, currentRegistry);\n        return {\n          success: true,\n          data: { executed: true },\n        };\n      }\n\n      case 'fill': {\n        if (!currentRegistry) {\n          return {\n            success: false,\n            error: 'No active snapshot - call snapshot action first',\n          };\n        }\n        const ref = request.params?.ref as string | undefined;\n        const value = request.params?.value as string | undefined;\n        if (!ref || value === undefined) {\n          return {\n            success: false,\n            error: 'Missing ref or value parameter for fill action',\n          };\n        }\n        await fillElement(ref, value, currentRegistry);\n        return {\n          success: true,\n          data: { executed: true },\n        };\n      }\n\n      case 'type': {\n        if (!currentRegistry) {\n          return {\n            success: false,\n            error: 'No active snapshot - call snapshot action first',\n          };\n        }\n        const ref = request.params?.ref;\n        const text = request.params?.text;\n        const delay = request.params?.delay;\n        if (!ref || text === undefined) return { success: false, error: 'Missing ref or text' };\n        await typeElement({ ref, text, delay }, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'focus': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const ref = request.params?.ref;\n        if (!ref) return { success: false, error: 'Missing ref' };\n        await focusElement(ref, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'hover': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const ref = request.params?.ref;\n        if (!ref) return { success: false, error: 'Missing ref' };\n        await hoverElement(ref, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'press': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const key = request.params?.key;\n        const ref = request.params?.ref;\n        if (!key) return { success: false, error: 'Missing key' };\n        await pressKey({ key, ref }, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'check': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const ref = request.params?.ref;\n        if (!ref) return { success: false, error: 'Missing ref' };\n        await setChecked(ref, true, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'uncheck': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const ref = request.params?.ref;\n        if (!ref) return { success: false, error: 'Missing ref' };\n        await setChecked(ref, false, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'select': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const ref = request.params?.ref;\n        const value = request.params?.value;\n        if (!ref || value === undefined) return { success: false, error: 'Missing ref or value' };\n        await selectOption({ ref, value }, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'get': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const what = request.params?.what as any;\n        const ref = request.params?.ref;\n        const selector = request.params?.selector;\n        const attrName = request.params?.attrName;\n        if (!what) return { success: false, error: 'Missing what' };\n        const result = await getInfo(\n          { what, ref, selector, attrName },\n          currentRegistry\n        );\n        return { success: true, data: { result } };\n      }\n\n      case 'is': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const what = request.params?.what as any;\n        const ref = request.params?.ref;\n        if (!what || !ref) return { success: false, error: 'Missing what or ref' };\n        const result = await checkState(\n          { what, ref },\n          currentRegistry\n        );\n        return { success: true, data: { result } };\n      }\n\n      case 'scroll': {\n        const direction = request.params?.direction as any;\n        const pixels = request.params?.pixels;\n        await scroll({ direction, pixels }, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'scrollintoview': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const ref = request.params?.ref;\n        if (!ref) return { success: false, error: 'Missing ref' };\n        await scrollIntoView(ref, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'wait': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const ms = request.params?.ms;\n        const ref = request.params?.ref;\n        const selector = request.params?.selector;\n        await wait({ ms, ref, selector }, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'drag': {\n        if (!currentRegistry) {\n          return { success: false, error: 'No active snapshot - call snapshot action first' };\n        }\n        const src = request.params?.src;\n        const dst = request.params?.dst;\n        if (!src || !dst) return { success: false, error: 'Missing src or dst' };\n        await dragAndDrop({ src, dst }, currentRegistry);\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'find': {\n        if (!currentRegistry) {\n          currentRegistry = createRefRegistry();\n        }\n        const locator = request.params?.locator as any;\n        const value = request.params?.value;\n        if (!locator || !value) return { success: false, error: 'Missing locator or value' };\n        const ref = await findElement(\n          { locator, value, text: request.params?.text },\n          currentRegistry\n        );\n        // Return array format per protocol spec: [{ ref: \"...\", nodeId: \"...\" }]\n        const result = ref ? [{ ref, nodeId: ref }] : [];\n        return { success: true, data: { result } };\n      }\n\n      case 'mouse': {\n        const action = request.params?.action as any;\n        if (!action) return { success: false, error: 'Missing action' };\n        await mouseAction({\n          action,\n          x: request.params?.x,\n          y: request.params?.y,\n          button: request.params?.button,\n          dx: request.params?.dx,\n          dy: request.params?.dy\n        });\n        return { success: true, data: { executed: true } };\n      }\n\n      case 'upload': {\n        return { success: false, error: `Action \"${request.action}\" not yet implemented` };\n      }\n\n      default: {\n        const _exhaustive: never = request.action;\n        return {\n          success: false,\n          error: `Unknown action: ${_exhaustive}`,\n        };\n      }\n    }\n  } catch (error) {\n    console.error('[Executor] Action failed:', error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    };\n  }\n}\n\n/**\n * Clear the current ref registry\n */\nexport function clearRegistry(): void {\n  currentRegistry = null;\n}\n", "/**\n * Content Script Entry Point\n * Listens for messages from background script and executes actions\n */\n\nimport type { ContentRequest, ContentResponse } from '../shared/messages';\nimport { executeAction } from './executor';\n\n/**\n * Validate message as ContentRequest\n */\nfunction isValidContentRequest(message: unknown): message is ContentRequest {\n  if (!message || typeof message !== 'object') {\n    return false;\n  }\n\n  const msg = message as Record<string, unknown>;\n  const validActions = [\n    'snapshot', 'click', 'dblclick', 'fill', 'type', 'press', 'hover', 'focus', 'check', 'uncheck', 'select', 'get', 'is',\n    'drag', 'upload', 'scroll', 'scrollintoview', 'wait', 'eval', 'find', 'mouse'\n  ];\n\n  if (typeof msg.action !== 'string' || !validActions.includes(msg.action)) {\n    return false;\n  }\n\n  const params = msg.params;\n  if (params !== undefined && (typeof params !== 'object' || params === null)) {\n    return false;\n  }\n\n  if (msg.action === 'snapshot') {\n    if (params === undefined) {\n      return true;\n    }\n    const timeout = (params as Record<string, unknown>).timeout;\n    return timeout === undefined || typeof timeout === 'number';\n  }\n\n  if (msg.action === 'click' || msg.action === 'dblclick' || msg.action === 'hover' || msg.action === 'focus' || msg.action === 'check' || msg.action === 'uncheck') {\n    if (!params) {\n      return false;\n    }\n    return typeof (params as Record<string, unknown>).ref === 'string';\n  }\n\n  if (msg.action === 'fill') {\n    if (!params) {\n      return false;\n    }\n    const paramRecord = params as Record<string, unknown>;\n    return typeof paramRecord.ref === 'string' && typeof paramRecord.value === 'string';\n  }\n\n  if (msg.action === 'type') {\n    if (!params) {\n      return false;\n    }\n    const paramRecord = params as Record<string, unknown>;\n    return (\n      typeof paramRecord.ref === 'string' &&\n      typeof paramRecord.text === 'string' &&\n      (paramRecord.delay === undefined || typeof paramRecord.delay === 'number')\n    );\n  }\n\n  if (msg.action === 'press') {\n    if (!params) {\n      return false;\n    }\n    const paramRecord = params as Record<string, unknown>;\n    return (\n      typeof paramRecord.key === 'string' &&\n      (paramRecord.ref === undefined || typeof paramRecord.ref === 'string')\n    );\n  }\n\n  if (msg.action === 'select') {\n    if (!params) {\n      return false;\n    }\n    const paramRecord = params as Record<string, unknown>;\n    return typeof paramRecord.ref === 'string' && typeof paramRecord.value === 'string';\n  }\n\n  if (msg.action === 'get') {\n    if (!params) {\n      return false;\n    }\n    const paramRecord = params as Record<string, unknown>;\n    return typeof paramRecord.what === 'string';\n  }\n\n  if (msg.action === 'is') {\n    if (!params) {\n      return false;\n    }\n    const paramRecord = params as Record<string, unknown>;\n    return typeof paramRecord.what === 'string' && typeof paramRecord.ref === 'string';\n  }\n\n  if (msg.action === 'scroll') {\n    if (!params) return false;\n    const p = params as Record<string, unknown>;\n    return typeof p.direction === 'string' && (p.pixels === undefined || typeof p.pixels === 'number');\n  }\n\n  if (msg.action === 'scrollintoview') {\n    if (!params) return false;\n    return typeof (params as Record<string, unknown>).ref === 'string';\n  }\n\n  if (msg.action === 'wait') {\n    if (!params) return true; // wait can have no params (default wait)\n    const p = params as Record<string, unknown>;\n    return (\n      (p.ms === undefined || typeof p.ms === 'number') &&\n      (p.ref === undefined || typeof p.ref === 'string') &&\n      (p.selector === undefined || typeof p.selector === 'string')\n    );\n  }\n\n  // Placeholder validation for other actions\n  if (['drag', 'upload', 'find', 'mouse'].includes(msg.action)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Initialize content script\n * - Set up chrome.runtime message listener\n * - Handle incoming action requests\n */\nfunction init(): void {\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    // Handle ping (used to check if content script is loaded)\n    if (message && typeof message === 'object' && (message as Record<string, unknown>).action === 'ping') {\n      sendResponse({ success: true, pong: true });\n      return true;\n    }\n\n    // Validate message\n    if (!isValidContentRequest(message)) {\n      console.error('[Content Script] Invalid message format:', message);\n      sendResponse({\n        success: false,\n        error: 'Invalid message format',\n      } as ContentResponse);\n      return true; // Keep channel open for consistency\n    }\n\n    // Execute action asynchronously\n    executeAction(message)\n      .then((response) => {\n        console.log('[Content Script] Action completed:', message.action);\n        sendResponse(response);\n      })\n      .catch((error) => {\n        console.error('[Content Script] Action failed:', message.action, error);\n        sendResponse({\n          success: false,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        } as ContentResponse);\n      });\n\n    // Return true to indicate we'll send response asynchronously\n    return true;\n  });\n\n  console.log('[Content Script] Initialized');\n}\n\n// Initialize on load\ninit();\n"],
  "mappings": "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",
  "names": ["isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "isElementVisible", "delay"]
}
