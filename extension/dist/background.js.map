{
  "version": 3,
  "sources": ["../src/shared/types.ts", "../src/background/storage.ts", "../src/background/websocket.ts", "../src/background/router.ts", "../src/background/tabs.ts", "../src/background/index.ts"],
  "sourcesContent": ["/**\n * Protocol Types\n * Defines the WebSocket communication protocol between daemon and extension\n * \n * SESSION MODEL:\n * - ONE WINDOW = ONE SESSION. Each browser window gets a unique session ID.\n * - Multiple windows can share the same profile (1 profile \u2192 many sessions).\n * - Session ID is assigned by daemon during handshake, cached by extension.\n * - Extension reconnects with cached session_id for session reattachment.\n */\n\n// =============================================================================\n// COMMAND TYPES (Agent -> Extension)\n// =============================================================================\n\nexport type CommandType =\n  | 'snapshot' | 'click' | 'dblclick' | 'fill' | 'type' | 'press' | 'hover' | 'focus' | 'check' | 'uncheck' | 'select'\n  | 'tab' | 'open' | 'get' | 'is'\n  | 'drag' | 'upload' | 'scroll' | 'scrollintoview' | 'wait' | 'screenshot' | 'pdf' | 'eval' | 'close'\n  | 'back' | 'forward' | 'reload' | 'find' | 'mouse';\n\nexport interface SnapshotParams {\n  timeout?: number;\n}\n\nexport interface ClickParams {\n  ref: string;\n}\n\nexport interface FillParams {\n  ref: string;\n  value: string;\n}\n\nexport interface TypeParams {\n  ref: string;\n  text: string;\n  delay?: number;\n}\n\nexport interface PressParams {\n  ref?: string;\n  key: string;\n}\n\nexport interface HoverParams {\n  ref: string;\n}\n\nexport interface FocusParams {\n  ref: string;\n}\n\nexport interface CheckParams {\n  ref: string;\n}\n\nexport interface UncheckParams {\n  ref: string;\n}\n\nexport interface SelectParams {\n  ref: string;\n  value: string;\n}\n\nexport interface OpenParams {\n  url: string;\n}\n\nexport interface GetParams {\n  what: 'text' | 'html' | 'value' | 'attr' | 'title' | 'url' | 'count' | 'box';\n  ref?: string;\n  selector?: string;\n  attrName?: string;\n}\n\nexport interface IsParams {\n  what: 'visible' | 'enabled' | 'checked';\n  ref: string;\n}\n\nexport interface DragParams {\n  src: string;\n  dst: string;\n}\n\nexport interface UploadParams {\n  ref: string;\n  files: string[];\n}\n\nexport interface ScrollParams {\n  direction: 'up' | 'down' | 'left' | 'right';\n  pixels?: number;\n}\n\nexport interface WaitParams {\n  ref?: string;\n  selector?: string;\n  ms?: number;\n}\n\nexport interface ScreenshotParams {\n  path?: string;\n}\n\nexport interface PdfParams {\n  path: string;\n}\n\nexport interface EvalParams {\n  script: string;\n}\n\nexport interface FindParams {\n  locator: 'role' | 'text' | 'label' | 'placeholder' | 'alt' | 'title' | 'testid' | 'first' | 'last' | 'nth';\n  value: string;\n  action?: string;\n  text?: string;\n}\n\nexport interface MouseParams {\n  action: 'move' | 'down' | 'up' | 'wheel';\n  x?: number;\n  y?: number;\n  button?: number;\n  dx?: number;\n  dy?: number;\n}\n\nexport interface TabParams {\n  action: 'new' | 'list' | 'close' | 'switch';\n  url?: string;\n  tabId?: number;\n}\n\nexport type CommandParams =\n  | SnapshotParams\n  | ClickParams\n  | FillParams\n  | TypeParams\n  | PressParams\n  | HoverParams\n  | FocusParams\n  | CheckParams\n  | UncheckParams\n  | SelectParams\n  | TabParams\n  | OpenParams\n  | GetParams\n  | IsParams\n  | DragParams\n  | UploadParams\n  | ScrollParams\n  | WaitParams\n  | ScreenshotParams\n  | PdfParams\n  | EvalParams\n  | FindParams\n  | MouseParams;\n\n/**\n * Configuration\n * \n * TODO: Add sessionStorageKey field for chrome.storage key name\n * used to persist the cached session_id.\n */\nexport interface ExtensionConfig {\n  websocketUrl: string;\n  reconnectInterval: number;\n  maxReconnectAttempts: number;\n  heartbeatInterval: number;\n  heartbeatTimeout: number;\n  // TODO: Add sessionStorageKey for chrome.storage session persistence\n}\n\n// =============================================================================\n// RESPONSE TYPES (Extension -> Agent)\n// =============================================================================\n\nexport interface TabInfo {\n  id?: number;\n  url?: string;\n  title?: string;\n  active: boolean;\n}\n\nexport interface ResponseData {\n  executed?: boolean;\n  snapshot?: string;\n  result?: any;\n  tabs?: TabInfo[];\n  activeTabId?: number;\n  screenshot?: string;\n  pdf?: string;\n  url?: string;\n  title?: string;\n}\n\n/**\n * Command sent from agent to extension via WebSocket\n *\n * TODO: Add session_assignment message type for daemon handshake.\n * When extension connects, daemon responds with session_assigned containing\n * the final session_id which extension must cache in chrome.storage.\n */\nexport interface AgentCommand {\n  id: string;\n  type: CommandType;\n  params?: CommandParams;\n}\n\n/**\n * Response sent from extension to agent via WebSocket\n */\nexport interface AgentResponse {\n  id: string;\n  success: boolean;\n  error?: string;\n  data?: ResponseData;\n}\n\n/**\n * TODO: Add SessionAssignment message type for daemon handshake response.\n * Sent by daemon to extension after connection establishment.\n * Extension must persist this session_id for reconnection.\n */\n// export interface SessionAssignment {\n//   type: 'session_assigned';\n//   sessionId: string;\n// }\n\n// =============================================================================\n// REF REGISTRY (Snapshot-local element references)\n// =============================================================================\n\nexport interface RefEntry {\n  ref: string;\n  element: Element;\n}\n\nexport interface RefRegistry {\n  entries: Map<string, Element>;\n  clear(): void;\n  set(ref: string, element: Element): void;\n  get(ref: string): Element | undefined;\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nexport interface ExtensionConfig {\n  websocketUrl: string;\n  reconnectInterval: number;\n  maxReconnectAttempts: number;\n  heartbeatInterval: number;\n  heartbeatTimeout: number;\n}\n\ndeclare const process: { env: { WS_URL: string } };\n\nexport const DEFAULT_CONFIG: ExtensionConfig = {\n  websocketUrl: process.env.WS_URL || 'ws://localhost:9222',\n  reconnectInterval: 3000,\n  maxReconnectAttempts: 10,\n  heartbeatInterval: 30000,  // Send ping every 30 seconds\n  heartbeatTimeout: 10000,   // Wait 10 seconds for pong (aligned with daemon)\n};\n", "/**\n * Storage Module\n * \n * Handles caching and retrieval of session ID from chrome.storage.local.\n * Session IDs are cached per windowId to support multiple windows.\n * ONE WINDOW = ONE SESSION.\n */\n\n// =============================================================================\n// Constants\n// =============================================================================\n\nconst STORAGE_KEY_PREFIX = 'session_';\n\n// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Get cached session ID for a specific window.\n * \n * @param windowId - The Chrome window ID\n * @returns Promise resolving to cached session ID, or null if not cached\n */\nexport function getCachedSessionId(windowId: number): Promise<string | null> {\n  const key = `${STORAGE_KEY_PREFIX}${windowId}`;\n  return new Promise((resolve) => {\n    chrome.storage.local.get(key, (result) => {\n      const stored = result[key];\n      if (typeof stored === 'string' && stored.length > 0) {\n        resolve(stored);\n      } else {\n        resolve(null);\n      }\n    });\n  });\n}\n\n/**\n * Cache session ID for a specific window.\n * \n * @param windowId - The Chrome window ID\n * @param sessionId - The session ID to cache\n * @returns Promise resolving when cached\n */\nexport function setCachedSessionId(windowId: number, sessionId: string): Promise<void> {\n  const key = `${STORAGE_KEY_PREFIX}${windowId}`;\n  return new Promise((resolve) => {\n    chrome.storage.local.set({ [key]: sessionId }, () => {\n      resolve();\n    });\n  });\n}\n\n/**\n * Clear cached session ID for a specific window.\n * \n * @param windowId - The Chrome window ID\n * @returns Promise resolving when cleared\n */\nexport function clearCachedSessionId(windowId: number): Promise<void> {\n  const key = `${STORAGE_KEY_PREFIX}${windowId}`;\n  return new Promise((resolve) => {\n    chrome.storage.local.remove(key, () => {\n      resolve();\n    });\n  });\n}\n", "import type { AgentCommand, AgentResponse, ExtensionConfig } from '../shared/types';\nimport { getCachedSessionId, setCachedSessionId } from './storage';\n\nexport type CommandHandler = (command: AgentCommand, windowId: number) => Promise<AgentResponse>;\n\n// =============================================================================\n// CONNECTION STATE\n// =============================================================================\n\nexport enum ConnectionState {\n  DISCONNECTED = 'DISCONNECTED',\n  CONNECTING = 'CONNECTING',\n  CONNECTED = 'CONNECTED',\n}\n\nexport interface WebSocketManager {\n  connect(): Promise<void>;\n  disconnect(): void;\n  send(response: AgentResponse): void;\n  isConnected(): boolean;\n  getState(): ConnectionState;\n  getReconnectAttempts(): number;\n  attemptReconnect(): void;\n}\n\nexport interface WebSocketCallbacks {\n  onStateChange?: (state: ConnectionState) => void;\n  onMaxReconnectAttemptsReached?: () => void;\n}\n\n/**\n * Create a WebSocket manager instance\n * @param config - Extension configuration\n * @param windowId - The browser window ID this manager is associated with\n * @param onCommand - Handler for incoming commands\n * @param callbacks - Optional callbacks for state changes\n */\nexport function createWebSocketManager(\n  config: ExtensionConfig,\n  windowId: number,\n  onCommand: CommandHandler,\n  callbacks?: WebSocketCallbacks\n): WebSocketManager {\n  let ws: WebSocket | null = null;\n  let state: ConnectionState = ConnectionState.DISCONNECTED;\n  let reconnectAttempts = 0;\n  let reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n  let heartbeatTimer: ReturnType<typeof setInterval> | null = null;\n  let pongTimer: ReturnType<typeof setTimeout> | null = null;\n  let awaitingPong = false;\n  let shouldReconnect = true;\n\n  function setState(newState: ConnectionState): void {\n    if (state !== newState) {\n      state = newState;\n      callbacks?.onStateChange?.(newState);\n    }\n  }\n\n  /**\n   * Start heartbeat interval\n   */\n  function startHeartbeat(): void {\n    stopHeartbeat();\n\n    heartbeatTimer = setInterval(() => {\n      if (!ws || ws.readyState !== WebSocket.OPEN) {\n        return;\n      }\n\n      if (awaitingPong) {\n        // Previous ping was not answered, connection is stale\n        console.warn('[WebSocket] Heartbeat timeout - connection stale');\n        ws.close();\n        return;\n      }\n\n      // Send ping\n      try {\n        if (pongTimer) {\n          clearTimeout(pongTimer);\n          pongTimer = null;\n        }\n        ws.send(JSON.stringify({ type: 'ping' }));\n        awaitingPong = true;\n        console.log('[WebSocket] Ping sent');\n\n        // Set timeout for pong response\n        pongTimer = setTimeout(() => {\n          if (awaitingPong) {\n            console.warn('[WebSocket] Pong timeout - closing connection');\n            ws?.close();\n          }\n        }, config.heartbeatTimeout);\n      } catch (error) {\n        console.error('[WebSocket] Failed to send ping:', error);\n      }\n    }, config.heartbeatInterval);\n  }\n\n  /**\n   * Stop heartbeat interval\n   */\n  function stopHeartbeat(): void {\n    if (heartbeatTimer) {\n      clearInterval(heartbeatTimer);\n      heartbeatTimer = null;\n    }\n    if (pongTimer) {\n      clearTimeout(pongTimer);\n      pongTimer = null;\n    }\n    awaitingPong = false;\n  }\n\n  /**\n   * Handle pong response\n   */\n  function handlePong(): void {\n    awaitingPong = false;\n    if (pongTimer) {\n      clearTimeout(pongTimer);\n      pongTimer = null;\n    }\n    console.log('[WebSocket] Pong received');\n  }\n\n  const manager: WebSocketManager = {\n    async connect() {\n      if (state === ConnectionState.CONNECTING) {\n        console.log('[WebSocket] Already connecting');\n        return;\n      }\n      if (state === ConnectionState.CONNECTED) {\n        console.log('[WebSocket] Already connected');\n        return;\n      }\n\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n        reconnectTimer = null;\n      }\n\n      setState(ConnectionState.CONNECTING);\n      shouldReconnect = true;\n\n      // Load cached session ID for potential reattachment (per-window)\n      const cachedSessionId = await getCachedSessionId(windowId);\n\n      // Connect to generic endpoint - daemon assigns session via handshake\n      const wsUrl = `${config.websocketUrl}/ws`;\n      console.log(`[WebSocket:Window${windowId}] Connecting to daemon...`);\n\n      try {\n        ws = new WebSocket(wsUrl);\n\n        ws.onopen = () => {\n          setState(ConnectionState.CONNECTED);\n          reconnectAttempts = 0;\n          console.log(`[WebSocket:Window${windowId}] Connected - requesting session assignment`);\n          // Send registration message to get/reattach session\n          ws?.send(JSON.stringify({\n            type: 'register',\n            windowId,\n            cachedSessionId,\n          }));\n          // Daemon assigns unique session ID - ONE WINDOW = ONE SESSION\n          startHeartbeat();\n        };\n\n        ws.onmessage = async (event) => {\n          let payload: unknown = event.data;\n          if (typeof event.data === 'string') {\n            try {\n              payload = JSON.parse(event.data) as unknown;\n            } catch {\n              payload = event.data;\n            }\n          }\n\n          if (isPongMessage(payload)) {\n            handlePong();\n            return;\n          }\n\n          // Handle session assignment from daemon\n          if (isSessionAssignedMessage(payload)) {\n            setCachedSessionId(windowId, payload.sessionId);\n            console.log(`[WebSocket:Window${windowId}] Session assigned: ${payload.sessionId}`);\n            return;\n          }\n\n          const command = parseCommand(payload);\n          if (!command) {\n            console.error('[WebSocket] Invalid command format:', event.data);\n            return;\n          }\n\n          console.log(`[WebSocket:${windowId}] Received command:`, command.id);\n\n          try {\n            const response = await onCommand(command, windowId);\n            try {\n              manager.send(response);\n            } catch (sendError) {\n              console.error('[WebSocket] Failed to send response:', sendError);\n            }\n          } catch (error) {\n            console.error('[WebSocket] Command handler error:', error);\n            try {\n              manager.send({\n                id: command.id,\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error',\n              });\n            } catch (sendError) {\n              console.error('[WebSocket] Failed to send error response:', sendError);\n            }\n          }\n        };\n\n        ws.onerror = (error) => {\n          console.error(`[WebSocket:${windowId}] Error:`, error);\n        };\n\n        ws.onclose = () => {\n          setState(ConnectionState.DISCONNECTED);\n          ws = null;\n          stopHeartbeat();\n          console.log(`[WebSocket:${windowId}] Disconnected`);\n          if (shouldReconnect) {\n            manager.attemptReconnect();\n          }\n        };\n      } catch (error) {\n        setState(ConnectionState.DISCONNECTED);\n        console.error(`[WebSocket:${windowId}] Connection failed:`, error);\n        manager.attemptReconnect();\n      }\n    },\n\n    disconnect() {\n      shouldReconnect = false;\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n        reconnectTimer = null;\n      }\n      reconnectAttempts = 0; // Reset attempts on manual disconnect\n      stopHeartbeat();\n      if (ws) {\n        ws.close();\n        ws = null;\n      }\n      setState(ConnectionState.DISCONNECTED);\n      console.log(`[WebSocket:${windowId}] Disconnected`);\n    },\n\n    send(response: AgentResponse) {\n      if (!ws || ws.readyState !== WebSocket.OPEN) {\n        console.error(`[WebSocket:${windowId}] Cannot send: not connected`);\n        return;\n      }\n      try {\n        ws.send(JSON.stringify(response));\n      } catch (error) {\n        console.error(`[WebSocket:${windowId}] Send error:`, error);\n      }\n    },\n\n    isConnected() {\n      return state === ConnectionState.CONNECTED;\n    },\n\n    getState() {\n      return state;\n    },\n\n    getReconnectAttempts() {\n      return reconnectAttempts;\n    },\n\n    attemptReconnect() {\n      if (reconnectAttempts >= config.maxReconnectAttempts) {\n        console.error('[WebSocket] Max reconnection attempts reached');\n        callbacks?.onMaxReconnectAttemptsReached?.();\n        return;\n      }\n\n      if (state === ConnectionState.CONNECTING || state === ConnectionState.CONNECTED) {\n        return;\n      }\n\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n        reconnectTimer = null;\n      }\n\n      reconnectAttempts++;\n      const delay = Math.min(\n        config.reconnectInterval * Math.pow(2, reconnectAttempts - 1),\n        30000 // Cap at 30 seconds\n      );\n\n      console.log(`[WebSocket] Reconnecting in ${delay}ms (attempt ${reconnectAttempts})`);\n\n      reconnectTimer = setTimeout(() => {\n        manager.connect();\n      }, delay);\n    },\n  };\n\n  return manager;\n}\n\n/**\n * Validate an incoming message as AgentCommand\n */\nfunction parseCommand(data: unknown): AgentCommand | null {\n  try {\n    if (typeof data === 'string') {\n      const parsed = JSON.parse(data) as unknown;\n      return validateCommand(parsed);\n    }\n    return validateCommand(data);\n  } catch (error) {\n    console.error('[WebSocket] Parse error:', error);\n    return null;\n  }\n}\n\nfunction isPongMessage(payload: unknown): boolean {\n  return (\n    payload !== null &&\n    typeof payload === 'object' &&\n    'type' in payload &&\n    (payload as { type?: unknown }).type === 'pong'\n  );\n}\n\ninterface SessionAssignedMessage {\n  type: 'session_assigned';\n  sessionId: string;\n}\n\nfunction isSessionAssignedMessage(payload: unknown): payload is SessionAssignedMessage {\n  return (\n    payload !== null &&\n    typeof payload === 'object' &&\n    'type' in payload &&\n    (payload as { type?: unknown }).type === 'session_assigned' &&\n    'sessionId' in payload &&\n    typeof (payload as { sessionId?: unknown }).sessionId === 'string'\n  );\n}\n\n/**\n * Validate command structure\n */\nfunction validateCommand(obj: unknown): AgentCommand | null {\n  if (!obj || typeof obj !== 'object') {\n    return null;\n  }\n\n  const cmd = obj as Record<string, unknown>;\n\n  if (typeof cmd.id !== 'string' || !cmd.id) {\n    return null;\n  }\n\n  if (typeof cmd.type !== 'string' || ![\n    'snapshot', 'click', 'dblclick', 'fill', 'type', 'press', 'hover', 'focus', 'check', 'uncheck', 'select', 'tab', 'open', 'get', 'is',\n    'drag', 'upload', 'scroll', 'scrollintoview', 'wait', 'screenshot', 'pdf', 'eval', 'close', 'back', 'forward', 'reload', 'find', 'mouse'\n  ].includes(cmd.type)) {\n    return null;\n  }\n\n  // Validate params is undefined or an object\n  const params = cmd.params;\n  if (params !== undefined && (typeof params !== 'object' || params === null)) {\n    return null;\n  }\n\n  return {\n    id: cmd.id,\n    type: cmd.type as AgentCommand['type'],\n    params: params as AgentCommand['params'],\n  };\n}\n", "import type { AgentCommand, AgentResponse, ResponseData } from '../shared/types';\nimport type { ContentRequest, ContentResponse, ActionType } from '../shared/messages';\n\nconst lastTargetTabIds = new Map<number, number>();\n\n/**\n * Clear the last target tab ID if it matches the given tab ID\n * Called when a tab is closed to prevent commands running on wrong tabs\n */\nexport function clearTargetTabIfMatch(tabId: number, windowId: number): void {\n  const lastTabId = lastTargetTabIds.get(windowId);\n  if (lastTabId === tabId) {\n    lastTargetTabIds.delete(windowId);\n  }\n}\n\nexport async function routeCommand(command: AgentCommand, windowId: number): Promise<AgentResponse> {\n\n  const tab = await getTargetTab(command.type, windowId);\n\n  if (!tab) {\n    return {\n      id: command.id,\n      success: false,\n      error: 'No active tab found',\n    };\n  }\n\n  if (!tab.id) {\n    return {\n      id: command.id,\n      success: false,\n      error: 'Tab has no ID',\n    };\n  }\n\n  if (!tab.url || !isValidTabUrl(tab.url)) {\n    return {\n      id: command.id,\n      success: false,\n      error: 'Tab has invalid URL (likely a browser page)',\n    };\n  }\n\n  if (command.type === 'snapshot') {\n    lastTargetTabIds.set(windowId, tab.id!);\n  }\n\n  if (command.type === 'open') {\n    const url = (command.params as any)?.url;\n    if (!url) {\n      return { id: command.id, success: false, error: 'Missing URL for open command' };\n    }\n    await chrome.tabs.update(tab.id, { url });\n    lastTargetTabIds.set(windowId, tab.id!);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'back') {\n    await chrome.tabs.goBack(tab.id);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'forward') {\n    await chrome.tabs.goForward(tab.id);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'reload') {\n    await chrome.tabs.reload(tab.id);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'close') {\n    await chrome.tabs.remove(tab.id);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'screenshot') {\n    if (tab.windowId === undefined) {\n      return { id: command.id, success: false, error: 'Tab has no associated window' };\n    }\n    try {\n      const dataUrl = await chrome.tabs.captureVisibleTab(tab.windowId, { format: 'png' });\n      return { id: command.id, success: true, data: { screenshot: dataUrl } };\n    } catch (error) {\n      return { \n        id: command.id, \n        success: false, \n        error: error instanceof Error ? error.message : 'Screenshot capture failed (window may be minimized or not visible)' \n      };\n    }\n  }\n\n  if (command.type === 'pdf') {\n    return new Promise((resolve) => {\n      const target = { tabId: tab.id! };\n      chrome.debugger.attach(target, '1.3', async () => {\n        if (chrome.runtime.lastError) {\n          resolve({ id: command.id, success: false, error: chrome.runtime.lastError.message });\n          return;\n        }\n\n        chrome.debugger.sendCommand(target, 'Page.printToPDF', {}, (result: any) => {\n          const error = chrome.runtime.lastError;\n          chrome.debugger.detach(target);\n\n          if (error) {\n            resolve({ id: command.id, success: false, error: error.message });\n          } else {\n            // Use 'pdf' field per protocol spec\n            resolve({ id: command.id, success: true, data: { pdf: result.data } });\n          }\n        });\n      });\n    });\n  }\n\n  if (command.type === 'upload') {\n    const ref = (command.params as any)?.ref;\n    const files = (command.params as any)?.files;\n    if (!ref || !files) return { id: command.id, success: false, error: 'Missing ref or files' };\n\n    return new Promise((resolve) => {\n      const target = { tabId: tab.id! };\n      chrome.debugger.attach(target, '1.3', async () => {\n        if (chrome.runtime.lastError) {\n          resolve({ id: command.id, success: false, error: chrome.runtime.lastError.message });\n          return;\n        }\n\n        // 1. Get the document to get the root nodeId\n        chrome.debugger.sendCommand(target, 'DOM.getDocument', {}, async (doc: any) => {\n          // 2. Find the element using a selector (we'll inject a temporary attribute to find it)\n          await chrome.scripting.executeScript({\n            target: { tabId: tab.id! },\n            func: (refId: string) => {\n              // This is a bit hacky but works: find the element in the registry and mark it\n              // @ts-ignore\n              const el = window.__REF_REGISTRY__?.get(refId);\n              if (el) el.setAttribute('data-upload-target', 'true');\n            },\n            args: [ref]\n          });\n\n          chrome.debugger.sendCommand(target, 'DOM.querySelector', {\n            nodeId: doc.root.nodeId,\n            selector: '[data-upload-target=\"true\"]'\n          }, (node: any) => {\n            if (!node || !node.nodeId) {\n              chrome.debugger.detach(target);\n              resolve({ id: command.id, success: false, error: 'Could not find upload target element' });\n              return;\n            }\n\n            // 3. Set the files\n            chrome.debugger.sendCommand(target, 'DOM.setFileInputFiles', {\n              nodeId: node.nodeId,\n              files: files\n            }, () => {\n              const error = chrome.runtime.lastError;\n\n              // Cleanup attribute\n              chrome.scripting.executeScript({\n                target: { tabId: tab.id! },\n                func: () => document.querySelector('[data-upload-target=\"true\"]')?.removeAttribute('data-upload-target')\n              });\n\n              chrome.debugger.detach(target);\n              if (error) {\n                resolve({ id: command.id, success: false, error: error.message });\n              } else {\n                resolve({ id: command.id, success: true, data: { executed: true } });\n              }\n            });\n          });\n        });\n      });\n    });\n  }\n\n  if (command.type === 'eval') {\n    const script = (command.params as any)?.script;\n    if (!script) return { id: command.id, success: false, error: 'Missing script' };\n\n    try {\n      const results = await chrome.scripting.executeScript({\n        target: { tabId: tab.id },\n        world: 'MAIN',\n        func: (scriptStr: string) => {\n          try {\n            return new Function(scriptStr)();\n          } catch (e) {\n            return { error: e instanceof Error ? e.message : String(e) };\n          }\n        },\n        args: [script]\n      });\n\n      const result = results[0]?.result;\n      if (result && typeof result === 'object' && 'error' in result) {\n        return { id: command.id, success: false, error: result.error };\n      }\n\n      return { id: command.id, success: true, data: { result } };\n    } catch (error) {\n      console.error('[Router] Eval failed:', error);\n      return { id: command.id, success: false, error: error instanceof Error ? error.message : String(error) };\n    }\n  }\n\n  const contentRequest: ContentRequest = {\n    action: command.type as ActionType,\n    params: command.params as ContentRequest['params'],\n  };\n\n  try {\n    const contentResponse = await sendToContentScript(tab.id, contentRequest);\n    return {\n      id: command.id,\n      success: contentResponse.success,\n      data: contentResponse.data as ResponseData | undefined,\n      error: contentResponse.error,\n    };\n  } catch (error) {\n    return {\n      id: command.id,\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to send message to content script',\n    };\n  }\n}\n\nasync function getActiveTab(windowId: number): Promise<chrome.tabs.Tab | null> {\n  const tabs = await chrome.tabs.query({\n    active: true,\n    windowId,\n  });\n  return tabs[0] || null;\n}\n\nasync function getTargetTab(commandType: AgentCommand['type'], windowId: number): Promise<chrome.tabs.Tab | null> {\n  const lastTargetTabId = lastTargetTabIds.get(windowId) ?? null;\n  if (commandType !== 'snapshot' && lastTargetTabId !== null) {\n    try {\n      const previousTab = await chrome.tabs.get(lastTargetTabId);\n      if (previousTab?.url && isValidTabUrl(previousTab.url)) {\n        return previousTab;\n      }\n    } catch {\n      // Fall back to active tab\n    }\n  }\n\n  return getActiveTab(windowId);\n}\n\nfunction isValidTabUrl(url: string): boolean {\n  // Allow about:blank as it's a common starting point\n  if (url === 'about:blank') return true;\n\n  // Exclude browser internal pages\n  return !url.startsWith('chrome://') &&\n    !url.startsWith('chrome-extension://') &&\n    !url.startsWith('about:') &&\n    !url.startsWith('edge://') &&\n    !url.startsWith('moz-extension://') &&\n    !url.startsWith('devtools://');\n}\n\nasync function pingContentScript(tabId: number): Promise<boolean> {\n  return new Promise((resolve) => {\n    chrome.tabs.sendMessage(tabId, { action: 'ping' }, (response) => {\n      if (chrome.runtime.lastError) {\n        resolve(false);\n      } else {\n        resolve(true);\n      }\n    });\n  });\n}\n\nasync function ensureContentScriptInjected(tabId: number): Promise<void> {\n  // Try to ping the content script first\n  if (await pingContentScript(tabId)) {\n    return;\n  }\n\n  // Content script not present, inject it\n  console.log('[Router] Content script not found, injecting...');\n  await chrome.scripting.executeScript({\n    target: { tabId },\n    files: ['dist/content.js'],\n  });\n\n  // Retry ping with exponential backoff to verify injection succeeded\n  const maxRetries = 5;\n  for (let i = 0; i < maxRetries; i++) {\n    const delay = 100 * Math.pow(2, i); // 100, 200, 400, 800, 1600ms\n    await new Promise((resolve) => setTimeout(resolve, delay));\n    \n    if (await pingContentScript(tabId)) {\n      console.log('[Router] Content script injected and responding');\n      return;\n    }\n  }\n\n  throw new Error('Content script failed to initialize after injection');\n}\n\nasync function sendToContentScript(tabId: number, request: ContentRequest): Promise<ContentResponse> {\n  // Ensure content script is injected first\n  await ensureContentScriptInjected(tabId);\n\n  return new Promise((resolve, reject) => {\n    // Set a timeout to prevent hanging\n    const timeout = setTimeout(() => {\n      reject(new Error('Content script message timeout'));\n    }, 10000); // 10 second timeout\n\n    chrome.tabs.sendMessage(tabId, request, (response) => {\n      clearTimeout(timeout);\n\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n      } else if (response) {\n        resolve(response as ContentResponse);\n      } else {\n        reject(new Error('No response from content script'));\n      }\n    });\n  });\n}\n", "/**\n * Tab Management\n * Handles tab-related commands using the chrome.tabs API\n */\n\nimport type { TabParams, AgentResponse, TabInfo } from '../shared/types';\n\n/**\n * Handle tab-related commands\n * @param params - Tab command parameters\n * @returns Response data\n */\nexport async function handleTabCommand(\n    params: TabParams,\n    windowId: number\n): Promise<Omit<AgentResponse, 'id'>> {\n    let { action, url, tabId } = params;\n\n    switch (action) {\n        case 'new': {\n            await chrome.tabs.create({ url, windowId });\n            return { success: true, data: { executed: true } };\n        }\n\n        case 'list': {\n            const tabs = await chrome.tabs.query({ windowId });\n\n            const tabList: TabInfo[] = tabs.map((t) => ({\n                id: t.id,\n                url: t.url,\n                title: t.title,\n                active: t.active,\n            }));\n\n            const activeTabId = await getActiveTabId(windowId);\n\n            return { success: true, data: { tabs: tabList, activeTabId } };\n        }\n                    \n        case 'close': {\n            tabId = tabId ?? (await getActiveTabId(windowId));\n\n            if (tabId === undefined) {\n                throw new Error('No active tab found to close');\n            }\n\n            const tab = await chrome.tabs.get(tabId);\n            if (tab.windowId !== windowId) {\n                throw new Error('tabId does not belong to the current window');\n            }\n\n            await chrome.tabs.remove(tabId);\n            return { success: true, data: { executed: true } };\n        }\n\n        case 'switch': {\n            if (tabId === undefined) throw new Error('tabId required for switch action');\n            const tab = await chrome.tabs.get(tabId);\n            if (tab.windowId !== windowId) {\n                throw new Error('tabId does not belong to the current window');\n            }\n            await chrome.tabs.update(tabId, { active: true });\n\n            // Also ensure the window is focused if needed\n            if (tab.windowId) {\n                await chrome.windows.update(tab.windowId, { focused: true });\n            }\n            return { success: true, data: { executed: true } };\n        }\n\n        default:\n            throw new Error(`Unknown tab action: ${action}`);\n    }\n}\n\n/**\n * Get the active tab ID for a given window\n */\nasync function getActiveTabId(windowId: number): Promise<number | undefined> {\n    const tabs = await chrome.tabs.query({ windowId, active: true });\n    return tabs[0]?.id;\n}\n", "/**\n * Background Service Worker Entry Point\n * Orchestrates WebSocket communication, command routing, and popup communication\n */\n\nimport { DEFAULT_CONFIG } from '../shared/types';\nimport type { AgentCommand, AgentResponse, ExtensionConfig } from '../shared/types';\nimport type {\n  PopupMessage,\n  StatusResponse,\n  SessionIdResponse,\n  ActivityLogEntry,\n  ActivityLogResponse,\n  ConnectionStatus,\n} from '../shared/messages';\nimport { getCachedSessionId } from './storage';\nimport { createWebSocketManager, type WebSocketManager, ConnectionState } from './websocket';\nimport { routeCommand, clearTargetTabIfMatch } from './router';\nimport { handleTabCommand } from './tabs';\n\n// =============================================================================\n// STATE\n// =============================================================================\n\nconst wsManagers = new Map<number, WebSocketManager>();\nlet config: ExtensionConfig = { ...DEFAULT_CONFIG };\nlet activityLog: ActivityLogEntry[] = [];\nconst MAX_LOG_ENTRIES = 100;\n\n// =============================================================================\n// WEBSOCKET LIFECYCLE\n// =============================================================================\n\nfunction createManager(windowId: number): WebSocketManager {\n  const manager = createWebSocketManager(config, windowId, handleCommand, {\n    onStateChange: (state: ConnectionState) => {\n      const stateMap: Record<ConnectionState, ConnectionStatus> = {\n        [ConnectionState.CONNECTED]: 'CONNECTED',\n        [ConnectionState.CONNECTING]: 'CONNECTING',\n        [ConnectionState.DISCONNECTED]: 'DISCONNECTED',\n      };\n\n      const status = stateMap[state];\n      addLogEntry('connection', `Window ${windowId}: ${status.toLowerCase()}`);\n      broadcastStatusUpdate();\n    },\n    onMaxReconnectAttemptsReached: () => {\n      addLogEntry('error', `Window ${windowId}: Max reconnect attempts reached`);\n    },\n  });\n\n  wsManagers.set(windowId, manager);\n  return manager;\n}\n\nfunction getOrCreateManager(windowId: number): WebSocketManager {\n  return wsManagers.get(windowId) ?? createManager(windowId);\n}\n\nasync function initWebSocket(): Promise<void> {\n  console.log('[Background] Connecting to daemon at:', config.websocketUrl);\n  \n  const windows = await chrome.windows.getAll();\n  windows.forEach((window) => {\n    if (window.id === undefined) return;\n    const manager = getOrCreateManager(window.id);\n    manager.connect();\n  });\n}\n\nasync function handleCommand(command: AgentCommand, windowId: number): Promise<AgentResponse> {\n  console.log(`[Background:${windowId}] Received command:`, command.id, command.type);\n  addLogEntry('command', `Window ${windowId}: ${command.type} (${command.id.slice(0, 8)}...)`);\n\n  try {\n    let response: AgentResponse;\n\n    if (command.type === 'tab') {\n      const result = await handleTabCommand(command.params as any, windowId);\n      response = {\n        id: command.id,\n        ...result,\n      };\n    } else {\n      response = await routeCommand(command, windowId);\n    }\n\n    console.log(`[Background:${windowId}] Command completed:`, command.id);\n    addLogEntry('response', `Window ${windowId}: ${command.type} ${response.success ? 'success' : 'failed'}`);\n    return response;\n  } catch (error) {\n    console.error(`[Background:${windowId}] Command failed:`, command.id, error);\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\n    addLogEntry('error', `Window ${windowId}: ${command.type} error: ${errorMsg}`);\n    return {\n      id: command.id,\n      success: false,\n      error: errorMsg,\n    };\n  }\n}\n\nasync function init(): Promise<void> {\n  await initWebSocket();\n  console.log('[Background] Service worker initialized');\n  addLogEntry('connection', 'Extension started');\n}\n\n// =============================================================================\n// POPUP COMMUNICATION\n// =============================================================================\n\nfunction handlePopupMessage(\n  message: PopupMessage,\n  sendResponse: (response: unknown) => void\n): boolean {\n  switch (message.type) {\n    case 'GET_STATUS': {\n      const states = Array.from(wsManagers.values()).map((manager) => manager.getState());\n      let connectionStatus: ConnectionStatus = 'DISCONNECTED';\n      if (states.some((state) => state === ConnectionState.CONNECTED)) {\n        connectionStatus = 'CONNECTED';\n      } else if (states.some((state) => state === ConnectionState.CONNECTING)) {\n        connectionStatus = 'CONNECTING';\n      }\n\n      const reconnectAttempts = states.length\n        ? Math.max(...Array.from(wsManagers.values()).map((manager) => manager.getReconnectAttempts()))\n        : 0;\n\n      const response: StatusResponse = {\n        connectionStatus,\n        websocketUrl: config.websocketUrl,\n        reconnectAttempts,\n        maxReconnectAttempts: config.maxReconnectAttempts,\n      };\n      sendResponse(response);\n      return true;\n    }\n\n    case 'CONNECT': {\n      void initWebSocket();\n      sendResponse({ success: true });\n      return true;\n    }\n\n    case 'DISCONNECT': {\n      wsManagers.forEach((manager) => manager.disconnect());\n      sendResponse({ success: true });\n      return true;\n    }\n\n    case 'UPDATE_URL': {\n      const url = message.payload?.url;\n      if (url) {\n        config.websocketUrl = url;\n        // Recreate manager with new URL on next connect\n        wsManagers.forEach((manager) => manager.disconnect());\n        wsManagers.clear();\n        addLogEntry('connection', `Server URL changed: ${url}`);\n      }\n      sendResponse({ success: true });\n      return true;\n    }\n\n    case 'GET_ACTIVITY_LOG': {\n      const response: ActivityLogResponse = {\n        entries: activityLog.slice(-50), // Return last 50 entries\n      };\n      sendResponse(response);\n      return true;\n    }\n\n    case 'GET_SESSION_ID': {\n      // Get the current window and return its session ID\n      chrome.windows.getCurrent().then(async (window) => {\n        if (window.id === undefined) {\n          sendResponse({ sessionId: null, windowId: -1 } as SessionIdResponse);\n          return;\n        }\n        const sessionId = await getCachedSessionId(window.id);\n        sendResponse({ sessionId, windowId: window.id } as SessionIdResponse);\n      });\n      return true; // Keep message channel open for async response\n    }\n\n    default:\n      return false;\n  }\n}\n\nfunction addLogEntry(type: ActivityLogEntry['type'], summary: string): void {\n  const entry: ActivityLogEntry = {\n    id: crypto.randomUUID(),\n    timestamp: Date.now(),\n    type,\n    summary,\n  };\n\n  activityLog.push(entry);\n\n  // Trim log to max entries\n  if (activityLog.length > MAX_LOG_ENTRIES) {\n    activityLog = activityLog.slice(-MAX_LOG_ENTRIES);\n  }\n\n  // Broadcast to popup if open\n  broadcastToPopup({ type: 'ACTIVITY_LOG_ENTRY', entry });\n}\n\nfunction broadcastToPopup(message: unknown): void {\n  // Use callback form to avoid treating chrome.runtime.sendMessage as a Promise\n  // and to safely ignore errors when the popup is not open.\n  try {\n    chrome.runtime.sendMessage(message, () => {\n      // swallow possible lastError when popup is not listening\n      // (e.g. popup closed) \u2014 nothing to do here\n      // eslint-disable-next-line no-unused-expressions\n      chrome.runtime.lastError;\n    });\n  } catch (e) {\n    // In some environments sendMessage may throw synchronously; ignore\n  }\n}\n\nfunction broadcastStatusUpdate(): void {\n  const states = Array.from(wsManagers.values()).map((manager) => manager.getState());\n  let status: ConnectionStatus = 'DISCONNECTED';\n  if (states.some((state) => state === ConnectionState.CONNECTED)) {\n    status = 'CONNECTED';\n  } else if (states.some((state) => state === ConnectionState.CONNECTING)) {\n    status = 'CONNECTING';\n  }\n\n  const reconnectAttempts = states.length\n    ? Math.max(...Array.from(wsManagers.values()).map((manager) => manager.getReconnectAttempts()))\n    : 0;\n\n  broadcastToPopup({\n    type: 'STATUS_UPDATE',\n    status,\n    reconnectAttempts,\n    maxReconnectAttempts: config.maxReconnectAttempts,\n  });\n}\n\n// Handle messages from popup\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  // Check if this is a popup message\n  if (message.type && ['GET_STATUS', 'GET_SESSION_ID', 'CONNECT', 'DISCONNECT', 'UPDATE_URL', 'GET_ACTIVITY_LOG'].includes(message.type)) {\n    return handlePopupMessage(message as PopupMessage, sendResponse);\n  }\n  return false;\n});\n\n// Clear target tab ID when a tab is closed to prevent commands running on wrong tabs\nchrome.tabs.onRemoved.addListener((tabId, removeInfo) => {\n  clearTargetTabIfMatch(tabId, removeInfo.windowId);\n});\n\n// Track new windows and create a connection per window\nchrome.windows.onCreated.addListener((window) => {\n  if (window.id === undefined) return;\n  const manager = getOrCreateManager(window.id);\n  manager.connect();\n});\n\nchrome.windows.onRemoved.addListener((windowId) => {\n  const manager = wsManagers.get(windowId);\n  if (manager) {\n    manager.disconnect();\n    wsManagers.delete(windowId);\n  }\n});\n\n// Initialize on service worker start\nvoid init();\n"],
  "mappings": "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",
  "names": ["config", "window"]
}
