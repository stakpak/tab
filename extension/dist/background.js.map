{
  "version": 3,
  "sources": ["../src/shared/types.ts", "../src/background/websocket.ts", "../src/background/router.ts", "../src/background/tabs.ts", "../src/background/index.ts"],
  "sourcesContent": ["/**\n * Protocol Types\n * Defines the WebSocket communication protocol between external agents and the extension\n */\n\n// =============================================================================\n// COMMAND TYPES (Agent -> Extension)\n// =============================================================================\n\nexport type CommandType =\n  | 'snapshot' | 'click' | 'dblclick' | 'fill' | 'type' | 'press' | 'hover' | 'focus' | 'check' | 'uncheck' | 'select'\n  | 'tab' | 'open' | 'get' | 'is'\n  | 'drag' | 'upload' | 'scroll' | 'scrollintoview' | 'wait' | 'screenshot' | 'pdf' | 'eval' | 'close'\n  | 'back' | 'forward' | 'reload' | 'find' | 'mouse';\n\nexport interface SnapshotParams {\n  timeout?: number;\n}\n\nexport interface ClickParams {\n  ref: string;\n}\n\nexport interface FillParams {\n  ref: string;\n  value: string;\n}\n\nexport interface TypeParams {\n  ref: string;\n  text: string;\n  delay?: number;\n}\n\nexport interface PressParams {\n  ref?: string;\n  key: string;\n}\n\nexport interface HoverParams {\n  ref: string;\n}\n\nexport interface FocusParams {\n  ref: string;\n}\n\nexport interface CheckParams {\n  ref: string;\n}\n\nexport interface UncheckParams {\n  ref: string;\n}\n\nexport interface SelectParams {\n  ref: string;\n  value: string;\n}\n\nexport interface OpenParams {\n  url: string;\n}\n\nexport interface GetParams {\n  what: 'text' | 'html' | 'value' | 'attr' | 'title' | 'url' | 'count' | 'box';\n  ref?: string;\n  selector?: string;\n  attrName?: string;\n}\n\nexport interface IsParams {\n  what: 'visible' | 'enabled' | 'checked';\n  ref: string;\n}\n\nexport interface DragParams {\n  src: string;\n  dst: string;\n}\n\nexport interface UploadParams {\n  ref: string;\n  files: string[];\n}\n\nexport interface ScrollParams {\n  direction: 'up' | 'down' | 'left' | 'right';\n  pixels?: number;\n}\n\nexport interface WaitParams {\n  ref?: string;\n  selector?: string;\n  ms?: number;\n}\n\nexport interface ScreenshotParams {\n  path?: string;\n}\n\nexport interface PdfParams {\n  path: string;\n}\n\nexport interface EvalParams {\n  script: string;\n}\n\nexport interface FindParams {\n  locator: 'role' | 'text' | 'label' | 'placeholder' | 'alt' | 'title' | 'testid' | 'first' | 'last' | 'nth';\n  value: string;\n  action?: string;\n  text?: string;\n}\n\nexport interface MouseParams {\n  action: 'move' | 'down' | 'up' | 'wheel';\n  x?: number;\n  y?: number;\n  button?: number;\n  dx?: number;\n  dy?: number;\n}\n\nexport interface TabParams {\n  action: 'new' | 'list' | 'close' | 'switch';\n  url?: string;\n  tabId?: number;\n}\n\nexport type CommandParams =\n  | SnapshotParams\n  | ClickParams\n  | FillParams\n  | TypeParams\n  | PressParams\n  | HoverParams\n  | FocusParams\n  | CheckParams\n  | UncheckParams\n  | SelectParams\n  | TabParams\n  | OpenParams\n  | GetParams\n  | IsParams\n  | DragParams\n  | UploadParams\n  | ScrollParams\n  | WaitParams\n  | ScreenshotParams\n  | PdfParams\n  | EvalParams\n  | FindParams\n  | MouseParams;\n\n/**\n * Command sent from agent to extension via WebSocket\n */\nexport interface AgentCommand {\n  id: string;\n  type: CommandType;\n  params?: CommandParams;\n}\n\n// =============================================================================\n// RESPONSE TYPES (Extension -> Agent)\n// =============================================================================\n\nexport interface TabInfo {\n  id?: number;\n  url?: string;\n  title?: string;\n  active: boolean;\n}\n\nexport interface ResponseData {\n  executed?: boolean;\n  snapshot?: string;\n  result?: any;\n  tabs?: TabInfo[];\n  screenshot?: string;\n}\n\n/**\n * Response sent from extension to agent via WebSocket\n */\nexport interface AgentResponse {\n  id: string;\n  success: boolean;\n  data?: ResponseData;\n  error?: string;\n}\n\n// =============================================================================\n// REF REGISTRY (Snapshot-local element references)\n// =============================================================================\n\nexport interface RefEntry {\n  ref: string;\n  element: Element;\n}\n\nexport interface RefRegistry {\n  entries: Map<string, Element>;\n  clear(): void;\n  set(ref: string, element: Element): void;\n  get(ref: string): Element | undefined;\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\nexport interface ExtensionConfig {\n  websocketUrl: string;\n  reconnectInterval: number;\n  maxReconnectAttempts: number;\n  heartbeatInterval: number;\n  heartbeatTimeout: number;\n}\n\nexport const DEFAULT_CONFIG: ExtensionConfig = {\n  websocketUrl: 'ws://localhost:8080',\n  reconnectInterval: 3000,\n  maxReconnectAttempts: 10,\n  heartbeatInterval: 30000,  // Send ping every 30 seconds\n  heartbeatTimeout: 5000,    // Wait 5 seconds for pong\n};\n", "import type { AgentCommand, AgentResponse, ExtensionConfig } from '../shared/types';\n\nexport type CommandHandler = (command: AgentCommand) => Promise<AgentResponse>;\n\n// =============================================================================\n// CONNECTION STATE\n// =============================================================================\n\nexport enum ConnectionState {\n  DISCONNECTED = 'DISCONNECTED',\n  CONNECTING = 'CONNECTING',\n  CONNECTED = 'CONNECTED',\n}\n\nexport interface WebSocketManager {\n  connect(): void;\n  disconnect(): void;\n  send(response: AgentResponse): void;\n  isConnected(): boolean;\n  getState(): ConnectionState;\n  getReconnectAttempts(): number;\n  attemptReconnect(): void;\n}\n\nexport interface WebSocketCallbacks {\n  onStateChange?: (state: ConnectionState) => void;\n}\n\n/**\n * Create a WebSocket manager instance\n * @param config - Extension configuration\n * @param onCommand - Handler for incoming commands\n * @param callbacks - Optional callbacks for state changes\n */\nexport function createWebSocketManager(\n  config: ExtensionConfig,\n  onCommand: CommandHandler,\n  callbacks?: WebSocketCallbacks\n): WebSocketManager {\n  let ws: WebSocket | null = null;\n  let state: ConnectionState = ConnectionState.DISCONNECTED;\n  let reconnectAttempts = 0;\n  let reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n  let heartbeatTimer: ReturnType<typeof setInterval> | null = null;\n  let pongTimer: ReturnType<typeof setTimeout> | null = null;\n  let awaitingPong = false;\n  let shouldReconnect = true;\n\n  function setState(newState: ConnectionState): void {\n    if (state !== newState) {\n      state = newState;\n      callbacks?.onStateChange?.(newState);\n    }\n  }\n\n  /**\n   * Start heartbeat interval\n   */\n  function startHeartbeat(): void {\n    stopHeartbeat();\n\n    heartbeatTimer = setInterval(() => {\n      if (!ws || ws.readyState !== WebSocket.OPEN) {\n        return;\n      }\n\n      if (awaitingPong) {\n        // Previous ping was not answered, connection is stale\n        console.warn('[WebSocket] Heartbeat timeout - connection stale');\n        ws.close();\n        return;\n      }\n\n      // Send ping\n      try {\n        if (pongTimer) {\n          clearTimeout(pongTimer);\n          pongTimer = null;\n        }\n        ws.send(JSON.stringify({ type: 'ping' }));\n        awaitingPong = true;\n        console.log('[WebSocket] Ping sent');\n\n        // Set timeout for pong response\n        pongTimer = setTimeout(() => {\n          if (awaitingPong) {\n            console.warn('[WebSocket] Pong timeout - closing connection');\n            ws?.close();\n          }\n        }, config.heartbeatTimeout);\n      } catch (error) {\n        console.error('[WebSocket] Failed to send ping:', error);\n      }\n    }, config.heartbeatInterval);\n  }\n\n  /**\n   * Stop heartbeat interval\n   */\n  function stopHeartbeat(): void {\n    if (heartbeatTimer) {\n      clearInterval(heartbeatTimer);\n      heartbeatTimer = null;\n    }\n    if (pongTimer) {\n      clearTimeout(pongTimer);\n      pongTimer = null;\n    }\n    awaitingPong = false;\n  }\n\n  /**\n   * Handle pong response\n   */\n  function handlePong(): void {\n    awaitingPong = false;\n    if (pongTimer) {\n      clearTimeout(pongTimer);\n      pongTimer = null;\n    }\n    console.log('[WebSocket] Pong received');\n  }\n\n  const manager: WebSocketManager = {\n    connect() {\n      if (state === ConnectionState.CONNECTING) {\n        console.log('[WebSocket] Already connecting');\n        return;\n      }\n      if (state === ConnectionState.CONNECTED) {\n        console.log('[WebSocket] Already connected');\n        return;\n      }\n\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n        reconnectTimer = null;\n      }\n\n      setState(ConnectionState.CONNECTING);\n      shouldReconnect = true;\n      console.log('[WebSocket] Connecting to', config.websocketUrl);\n\n      try {\n        ws = new WebSocket(config.websocketUrl);\n\n        ws.onopen = () => {\n          setState(ConnectionState.CONNECTED);\n          reconnectAttempts = 0;\n          console.log('[WebSocket] Connected');\n          startHeartbeat();\n        };\n\n        ws.onmessage = async (event) => {\n          let payload: unknown = event.data;\n          if (typeof event.data === 'string') {\n            try {\n              payload = JSON.parse(event.data) as unknown;\n            } catch {\n              payload = event.data;\n            }\n          }\n\n          if (isPongMessage(payload)) {\n            handlePong();\n            return;\n          }\n\n          const command = parseCommand(payload);\n          if (!command) {\n            console.error('[WebSocket] Invalid command format:', event.data);\n            return;\n          }\n\n          console.log('[WebSocket] Received command:', command.id);\n\n          try {\n            const response = await onCommand(command);\n            manager.send(response);\n          } catch (error) {\n            console.error('[WebSocket] Command handler error:', error);\n            manager.send({\n              id: command.id,\n              success: false,\n              error: error instanceof Error ? error.message : 'Unknown error',\n            });\n          }\n        };\n\n        ws.onerror = (error) => {\n          console.error('[WebSocket] Error:', error);\n        };\n\n        ws.onclose = () => {\n          setState(ConnectionState.DISCONNECTED);\n          ws = null;\n          stopHeartbeat();\n          console.log('[WebSocket] Disconnected');\n          if (shouldReconnect) {\n            manager.attemptReconnect();\n          }\n        };\n      } catch (error) {\n        setState(ConnectionState.DISCONNECTED);\n        console.error('[WebSocket] Connection failed:', error);\n        manager.attemptReconnect();\n      }\n    },\n\n    disconnect() {\n      shouldReconnect = false;\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n        reconnectTimer = null;\n      }\n      reconnectAttempts = 0; // Reset attempts on manual disconnect\n      stopHeartbeat();\n      if (ws) {\n        ws.close();\n        ws = null;\n      }\n      setState(ConnectionState.DISCONNECTED);\n      console.log('[WebSocket] Disconnected');\n    },\n\n    send(response: AgentResponse) {\n      if (!ws || ws.readyState !== WebSocket.OPEN) {\n        console.error('[WebSocket] Cannot send: not connected');\n        return;\n      }\n      try {\n        ws.send(JSON.stringify(response));\n      } catch (error) {\n        console.error('[WebSocket] Send error:', error);\n      }\n    },\n\n    isConnected() {\n      return state === ConnectionState.CONNECTED;\n    },\n\n    getState() {\n      return state;\n    },\n\n    getReconnectAttempts() {\n      return reconnectAttempts;\n    },\n\n    attemptReconnect() {\n      if (reconnectAttempts >= config.maxReconnectAttempts) {\n        console.error('[WebSocket] Max reconnection attempts reached');\n        return;\n      }\n\n      if (state === ConnectionState.CONNECTING || state === ConnectionState.CONNECTED) {\n        return;\n      }\n\n      if (reconnectTimer) {\n        clearTimeout(reconnectTimer);\n        reconnectTimer = null;\n      }\n\n      reconnectAttempts++;\n      const delay = Math.min(\n        config.reconnectInterval * Math.pow(2, reconnectAttempts - 1),\n        30000 // Cap at 30 seconds\n      );\n\n      console.log(`[WebSocket] Reconnecting in ${delay}ms (attempt ${reconnectAttempts})`);\n\n      reconnectTimer = setTimeout(() => {\n        manager.connect();\n      }, delay);\n    },\n  };\n\n  return manager;\n}\n\n/**\n * Validate an incoming message as AgentCommand\n */\nfunction parseCommand(data: unknown): AgentCommand | null {\n  try {\n    if (typeof data === 'string') {\n      const parsed = JSON.parse(data) as unknown;\n      return validateCommand(parsed);\n    }\n    return validateCommand(data);\n  } catch (error) {\n    console.error('[WebSocket] Parse error:', error);\n    return null;\n  }\n}\n\nfunction isPongMessage(payload: unknown): boolean {\n  return (\n    payload !== null &&\n    typeof payload === 'object' &&\n    'type' in payload &&\n    (payload as { type?: unknown }).type === 'pong'\n  );\n}\n\n/**\n * Validate command structure\n */\nfunction validateCommand(obj: unknown): AgentCommand | null {\n  if (!obj || typeof obj !== 'object') {\n    return null;\n  }\n\n  const cmd = obj as Record<string, unknown>;\n\n  if (typeof cmd.id !== 'string' || !cmd.id) {\n    return null;\n  }\n\n  if (typeof cmd.type !== 'string' || ![\n    'snapshot', 'click', 'dblclick', 'fill', 'type', 'press', 'hover', 'focus', 'check', 'uncheck', 'select', 'tab', 'open', 'get', 'is',\n    'drag', 'upload', 'scroll', 'scrollintoview', 'wait', 'screenshot', 'pdf', 'eval', 'close', 'back', 'forward', 'reload', 'find', 'mouse'\n  ].includes(cmd.type)) {\n    return null;\n  }\n\n  // Validate params is undefined or an object\n  const params = cmd.params;\n  if (params !== undefined && (typeof params !== 'object' || params === null)) {\n    return null;\n  }\n\n  return {\n    id: cmd.id,\n    type: cmd.type as AgentCommand['type'],\n    params: params as AgentCommand['params'],\n  };\n}\n", "import type { AgentCommand, AgentResponse, ResponseData } from '../shared/types';\nimport type { ContentRequest, ContentResponse, ActionType } from '../shared/messages';\n\nlet lastTargetTabId: number | null = null;\n\nexport async function routeCommand(command: AgentCommand): Promise<AgentResponse> {\n\n  const tab = await getTargetTab(command.type);\n\n  if (!tab) {\n    return {\n      id: command.id,\n      success: false,\n      error: 'No active tab found',\n    };\n  }\n\n  if (!tab.id) {\n    return {\n      id: command.id,\n      success: false,\n      error: 'Tab has no ID',\n    };\n  }\n\n  if (!tab.url || !isValidTabUrl(tab.url)) {\n    return {\n      id: command.id,\n      success: false,\n      error: 'Tab has invalid URL (likely a browser page)',\n    };\n  }\n\n  if (command.type === 'snapshot') {\n    lastTargetTabId = tab.id;\n  }\n\n  if (command.type === 'open') {\n    const url = (command.params as any)?.url;\n    if (!url) {\n      return { id: command.id, success: false, error: 'Missing URL for open command' };\n    }\n    await chrome.tabs.update(tab.id, { url });\n    lastTargetTabId = tab.id;\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'back') {\n    await chrome.tabs.goBack(tab.id);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'forward') {\n    await chrome.tabs.goForward(tab.id);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'reload') {\n    await chrome.tabs.reload(tab.id);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'close') {\n    await chrome.tabs.remove(tab.id);\n    return { id: command.id, success: true, data: { executed: true } };\n  }\n\n  if (command.type === 'screenshot') {\n    // tab.windowId is guaranteed to exist for a valid tab object\n    const dataUrl = await chrome.tabs.captureVisibleTab(tab.windowId!, { format: 'png' });\n    return { id: command.id, success: true, data: { screenshot: dataUrl } };\n  }\n\n  if (command.type === 'pdf') {\n    return new Promise((resolve) => {\n      const target = { tabId: tab.id! };\n      chrome.debugger.attach(target, '1.3', async () => {\n        if (chrome.runtime.lastError) {\n          resolve({ id: command.id, success: false, error: chrome.runtime.lastError.message });\n          return;\n        }\n\n        chrome.debugger.sendCommand(target, 'Page.printToPDF', {}, (result: any) => {\n          const error = chrome.runtime.lastError;\n          chrome.debugger.detach(target);\n\n          if (error) {\n            resolve({ id: command.id, success: false, error: error.message });\n          } else {\n            resolve({ id: command.id, success: true, data: { result: result.data } });\n          }\n        });\n      });\n    });\n  }\n\n  if (command.type === 'upload') {\n    const ref = (command.params as any)?.ref;\n    const files = (command.params as any)?.files;\n    if (!ref || !files) return { id: command.id, success: false, error: 'Missing ref or files' };\n\n    return new Promise((resolve) => {\n      const target = { tabId: tab.id! };\n      chrome.debugger.attach(target, '1.3', async () => {\n        if (chrome.runtime.lastError) {\n          resolve({ id: command.id, success: false, error: chrome.runtime.lastError.message });\n          return;\n        }\n\n        // 1. Get the document to get the root nodeId\n        chrome.debugger.sendCommand(target, 'DOM.getDocument', {}, async (doc: any) => {\n          // 2. Find the element using a selector (we'll inject a temporary attribute to find it)\n          await chrome.scripting.executeScript({\n            target: { tabId: tab.id },\n            func: (refId: string) => {\n              // This is a bit hacky but works: find the element in the registry and mark it\n              // @ts-ignore\n              const el = window.__REF_REGISTRY__?.get(refId);\n              if (el) el.setAttribute('data-upload-target', 'true');\n            },\n            args: [ref]\n          });\n\n          chrome.debugger.sendCommand(target, 'DOM.querySelector', {\n            nodeId: doc.root.nodeId,\n            selector: '[data-upload-target=\"true\"]'\n          }, (node: any) => {\n            if (!node || !node.nodeId) {\n              chrome.debugger.detach(target);\n              resolve({ id: command.id, success: false, error: 'Could not find upload target element' });\n              return;\n            }\n\n            // 3. Set the files\n            chrome.debugger.sendCommand(target, 'DOM.setFileInputFiles', {\n              nodeId: node.nodeId,\n              files: files\n            }, () => {\n              const error = chrome.runtime.lastError;\n\n              // Cleanup attribute\n              chrome.scripting.executeScript({\n                target: { tabId: tab.id },\n                func: () => document.querySelector('[data-upload-target=\"true\"]')?.removeAttribute('data-upload-target')\n              });\n\n              chrome.debugger.detach(target);\n              if (error) {\n                resolve({ id: command.id, success: false, error: error.message });\n              } else {\n                resolve({ id: command.id, success: true, data: { executed: true } });\n              }\n            });\n          });\n        });\n      });\n    });\n  }\n\n  if (command.type === 'eval') {\n    const script = (command.params as any)?.script;\n    if (!script) return { id: command.id, success: false, error: 'Missing script' };\n\n    try {\n      const results = await chrome.scripting.executeScript({\n        target: { tabId: tab.id },\n        world: 'MAIN',\n        func: (scriptStr: string) => {\n          try {\n            return new Function(scriptStr)();\n          } catch (e) {\n            return { error: e instanceof Error ? e.message : String(e) };\n          }\n        },\n        args: [script]\n      });\n\n      const result = results[0]?.result;\n      if (result && typeof result === 'object' && 'error' in result) {\n        return { id: command.id, success: false, error: result.error };\n      }\n\n      return { id: command.id, success: true, data: { result } };\n    } catch (error) {\n      console.error('[Router] Eval failed:', error);\n      return { id: command.id, success: false, error: error instanceof Error ? error.message : String(error) };\n    }\n  }\n\n  const contentRequest: ContentRequest = {\n    action: command.type as ActionType,\n    params: command.params as ContentRequest['params'],\n  };\n\n  try {\n    const contentResponse = await sendToContentScript(tab.id, contentRequest);\n    return {\n      id: command.id,\n      success: contentResponse.success,\n      data: contentResponse.data as ResponseData | undefined,\n      error: contentResponse.error,\n    };\n  } catch (error) {\n    return {\n      id: command.id,\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to send message to content script',\n    };\n  }\n}\n\nasync function getActiveTab(): Promise<chrome.tabs.Tab | null> {\n  const tabs = await chrome.tabs.query({\n    active: true,\n    currentWindow: true,\n  });\n  return tabs[0] || null;\n}\n\nasync function getTargetTab(commandType: AgentCommand['type']): Promise<chrome.tabs.Tab | null> {\n  if (commandType !== 'snapshot' && lastTargetTabId !== null) {\n    try {\n      const previousTab = await chrome.tabs.get(lastTargetTabId);\n      if (previousTab?.url && isValidTabUrl(previousTab.url)) {\n        return previousTab;\n      }\n    } catch {\n      // Fall back to active tab\n    }\n  }\n\n  return getActiveTab();\n}\n\nfunction isValidTabUrl(url: string): boolean {\n  // Allow about:blank as it's a common starting point\n  if (url === 'about:blank') return true;\n\n  // Exclude browser internal pages\n  return !url.startsWith('chrome://') &&\n    !url.startsWith('chrome-extension://') &&\n    !url.startsWith('about:') &&\n    !url.startsWith('edge://') &&\n    !url.startsWith('moz-extension://') &&\n    !url.startsWith('devtools://');\n}\n\nasync function ensureContentScriptInjected(tabId: number): Promise<void> {\n  try {\n    // Try to ping the content script first\n    await new Promise<void>((resolve, reject) => {\n      chrome.tabs.sendMessage(tabId, { action: 'ping' }, (response) => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message));\n        } else {\n          resolve();\n        }\n      });\n    });\n  } catch {\n    // Content script not present, inject it\n    console.log('[Router] Content script not found, injecting...');\n    await chrome.scripting.executeScript({\n      target: { tabId },\n      files: ['dist/content.js'],\n    });\n    // Give it a moment to initialize\n    await new Promise((resolve) => setTimeout(resolve, 100));\n    console.log('[Router] Content script injected');\n  }\n}\n\nasync function sendToContentScript(tabId: number, request: ContentRequest): Promise<ContentResponse> {\n  // Ensure content script is injected first\n  await ensureContentScriptInjected(tabId);\n\n  return new Promise((resolve, reject) => {\n    // Set a timeout to prevent hanging\n    const timeout = setTimeout(() => {\n      reject(new Error('Content script message timeout'));\n    }, 10000); // 10 second timeout\n\n    chrome.tabs.sendMessage(tabId, request, (response) => {\n      clearTimeout(timeout);\n\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n      } else if (response) {\n        resolve(response as ContentResponse);\n      } else {\n        reject(new Error('No response from content script'));\n      }\n    });\n  });\n}\n", "/**\n * Tab Management\n * Handles tab-related commands using the chrome.tabs API\n */\n\nimport type { TabParams, AgentResponse, TabInfo } from '../shared/types';\n\n/**\n * Handle tab-related commands\n * @param params - Tab command parameters\n * @returns Response data\n */\nexport async function handleTabCommand(params: TabParams): Promise<Omit<AgentResponse, 'id'>> {\n    const { action, url, tabId } = params;\n\n    switch (action) {\n        case 'new': {\n            await chrome.tabs.create({ url });\n            return { success: true, data: { executed: true } };\n        }\n\n        case 'list': {\n            const tabs = await chrome.tabs.query({});\n            const tabList: TabInfo[] = tabs.map((t) => ({\n                id: t.id,\n                url: t.url,\n                title: t.title,\n                active: t.active,\n            }));\n            return { success: true, data: { tabs: tabList } };\n        }\n\n        case 'close': {\n            if (tabId === undefined) throw new Error('tabId required for close action');\n            await chrome.tabs.remove(tabId);\n            return { success: true, data: { executed: true } };\n        }\n\n        case 'switch': {\n            if (tabId === undefined) throw new Error('tabId required for switch action');\n            await chrome.tabs.update(tabId, { active: true });\n\n            // Also ensure the window is focused if needed\n            const tab = await chrome.tabs.get(tabId);\n            if (tab.windowId) {\n                await chrome.windows.update(tab.windowId, { focused: true });\n            }\n            return { success: true, data: { executed: true } };\n        }\n\n        default:\n            throw new Error(`Unknown tab action: ${action}`);\n    }\n}\n", "/**\n * Background Service Worker Entry Point\n * Orchestrates WebSocket communication, command routing, and popup communication\n */\n\nimport { DEFAULT_CONFIG } from '../shared/types';\nimport type { AgentCommand, AgentResponse, ExtensionConfig } from '../shared/types';\nimport type {\n  PopupMessage,\n  StatusResponse,\n  ActivityLogEntry,\n  ActivityLogResponse,\n  ConnectionStatus,\n} from '../shared/messages';\nimport { createWebSocketManager, type WebSocketManager, ConnectionState } from './websocket';\nimport { routeCommand } from './router';\nimport { handleTabCommand } from './tabs';\n\n// =============================================================================\n// STATE\n// =============================================================================\n\nlet wsManager: WebSocketManager | null = null;\nlet config: ExtensionConfig = { ...DEFAULT_CONFIG };\nlet activityLog: ActivityLogEntry[] = [];\nconst MAX_LOG_ENTRIES = 100;\n\n// =============================================================================\n// WEBSOCKET LIFECYCLE\n// =============================================================================\n\nfunction createManager(): void {\n  wsManager = createWebSocketManager(config, handleCommand, {\n    onStateChange: (state: ConnectionState) => {\n      const stateMap: Record<ConnectionState, ConnectionStatus> = {\n        [ConnectionState.CONNECTED]: 'CONNECTED',\n        [ConnectionState.CONNECTING]: 'CONNECTING',\n        [ConnectionState.DISCONNECTED]: 'DISCONNECTED',\n      };\n\n      const status = stateMap[state];\n      addLogEntry('connection', `Status: ${status.toLowerCase()}`);\n      broadcastStatusUpdate();\n    },\n  });\n}\n\nfunction initWebSocket(): void {\n  if (!wsManager) {\n    createManager();\n  }\n  wsManager!.connect();\n}\n\n\n\nasync function handleCommand(command: AgentCommand): Promise<AgentResponse> {\n  console.log('[Background] Received command:', command.id, command.type);\n  addLogEntry('command', `${command.type} (${command.id.slice(0, 8)}...)`);\n\n  try {\n    let response: AgentResponse;\n\n    if (command.type === 'tab') {\n      const result = await handleTabCommand(command.params as any);\n      response = {\n        id: command.id,\n        ...result,\n      };\n    } else {\n      response = await routeCommand(command);\n    }\n\n    console.log('[Background] Command completed:', command.id);\n    addLogEntry('response', `${command.type} ${response.success ? 'success' : 'failed'}`);\n    return response;\n  } catch (error) {\n    console.error('[Background] Command failed:', command.id, error);\n    const errorMsg = error instanceof Error ? error.message : 'Unknown error';\n    addLogEntry('error', `${command.type} error: ${errorMsg}`);\n    return {\n      id: command.id,\n      success: false,\n      error: errorMsg,\n    };\n  }\n}\n\nfunction init(): void {\n  createManager();\n  wsManager!.connect();\n  console.log('[Background] Service worker initialized');\n  addLogEntry('connection', 'Extension started');\n}\n\n// Initialize on load\ninit();\n\n// =============================================================================\n// POPUP COMMUNICATION\n// =============================================================================\n\nfunction handlePopupMessage(\n  message: PopupMessage,\n  sendResponse: (response: unknown) => void\n): boolean {\n  switch (message.type) {\n    case 'GET_STATUS': {\n      if (!wsManager) {\n        createManager();\n      }\n\n      const stateMap: Record<ConnectionState, ConnectionStatus> = {\n        [ConnectionState.CONNECTED]: 'CONNECTED',\n        [ConnectionState.CONNECTING]: 'CONNECTING',\n        [ConnectionState.DISCONNECTED]: 'DISCONNECTED',\n      };\n\n      const response: StatusResponse = {\n        connectionStatus: stateMap[wsManager!.getState()],\n        websocketUrl: config.websocketUrl,\n        reconnectAttempts: wsManager!.getReconnectAttempts(),\n        maxReconnectAttempts: config.maxReconnectAttempts,\n      };\n      sendResponse(response);\n      return true;\n    }\n\n    case 'CONNECT': {\n      initWebSocket();\n      sendResponse({ success: true });\n      return true;\n    }\n\n    case 'DISCONNECT': {\n      if (wsManager) {\n        wsManager.disconnect();\n      }\n      sendResponse({ success: true });\n      return true;\n    }\n\n    case 'UPDATE_URL': {\n      const url = message.payload?.url;\n      if (url) {\n        config.websocketUrl = url;\n        // Recreate manager with new URL on next connect\n        if (wsManager) {\n          wsManager.disconnect();\n          wsManager = null;\n        }\n        addLogEntry('connection', `Server URL changed: ${url}`);\n      }\n      sendResponse({ success: true });\n      return true;\n    }\n\n    case 'GET_ACTIVITY_LOG': {\n      const response: ActivityLogResponse = {\n        entries: activityLog.slice(-50), // Return last 50 entries\n      };\n      sendResponse(response);\n      return true;\n    }\n\n    default:\n      return false;\n  }\n}\n\nfunction addLogEntry(type: ActivityLogEntry['type'], summary: string): void {\n  const entry: ActivityLogEntry = {\n    id: crypto.randomUUID(),\n    timestamp: Date.now(),\n    type,\n    summary,\n  };\n\n  activityLog.push(entry);\n\n  // Trim log to max entries\n  if (activityLog.length > MAX_LOG_ENTRIES) {\n    activityLog = activityLog.slice(-MAX_LOG_ENTRIES);\n  }\n\n  // Broadcast to popup if open\n  broadcastToPopup({ type: 'ACTIVITY_LOG_ENTRY', entry });\n}\n\nfunction broadcastToPopup(message: unknown): void {\n  // Use callback form to avoid treating chrome.runtime.sendMessage as a Promise\n  // and to safely ignore errors when the popup is not open.\n  try {\n    chrome.runtime.sendMessage(message, () => {\n      // swallow possible lastError when popup is not listening\n      // (e.g. popup closed) \u2014 nothing to do here\n      // eslint-disable-next-line no-unused-expressions\n      chrome.runtime.lastError;\n    });\n  } catch (e) {\n    // In some environments sendMessage may throw synchronously; ignore\n  }\n}\n\nfunction broadcastStatusUpdate(): void {\n  if (!wsManager) return;\n\n  const stateMap: Record<ConnectionState, ConnectionStatus> = {\n    [ConnectionState.CONNECTED]: 'CONNECTED',\n    [ConnectionState.CONNECTING]: 'CONNECTING',\n    [ConnectionState.DISCONNECTED]: 'DISCONNECTED',\n  };\n\n  broadcastToPopup({\n    type: 'STATUS_UPDATE',\n    status: stateMap[wsManager.getState()],\n    reconnectAttempts: wsManager.getReconnectAttempts(),\n    maxReconnectAttempts: config.maxReconnectAttempts,\n  });\n}\n\n// Handle messages from popup\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  // Check if this is a popup message\n  if (message.type && ['GET_STATUS', 'CONNECT', 'DISCONNECT', 'UPDATE_URL', 'GET_ACTIVITY_LOG'].includes(message.type)) {\n    return handlePopupMessage(message as PopupMessage, sendResponse);\n  }\n  return false;\n});\n\n"],
  "mappings": "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",
  "names": ["config"]
}
